---
theme: default
title: "HTML: async, defer, формы. JS: location, history, маршрутизация/ Курс по веб-разработке, 10 класс"
class: text-center
drawings:
  persist: false
transition: slide-left
mdc: true
fonts:
  sans: Montserrat
hideInToc: true
browserExporter: true
---

# Курс по веб-разработке

<h2 class="color-gray-400 fw-200">HTML: async, defer, формы.<br />JS: location, history, маршрутизация</h2>
---
transition: none
---

# HTML - атрибуты `async` и `defer`

<div></div>

По умолчанию загрузка скриптов (тэг `<script src="...">`) выполняется следующим образом:
- Браузер останавливает парсинг HTML
- Начинает загружать скрипт
- Дожидается полной загрузки
- Выполняет скрипт
- Только потом продолжает строить DOM

То есть, если поместить `<script>` в `<head>`, то на момент его запуска DOM-дерево будет пустым

---

# HTML - атрибуты `async` и `defer`

> `async` и `defer` - специальные атрибуты тэга `<script>`, контролирирующие процесс загрузки

- С обоими атрибутами загрузка скрипта будет происходить параллельно с HTML (то есть парсинг не остановится), поэтому общая скорость загрузки увеличится
- С `async` скрипт выполнится сразу, как только загрузится, с `defer` - только после того, как завершится процесс построения DOM-дерева
- Помимо этого, `defer` гарантирует порядок вывыполнения, то есть если вы загружаете несколько скриптов с `defer`, то они выполнятся друг после друга (даже если загрузились они в ином порядке). Также, выполнение скриптов с `defer` отклыдывает событие [`DOMContentLoaded`](https://doka.guide/js/event-domcontentloaded/)

```html
<head>
  <!-- Внешний скрипт для аналитики сайта -->
  <script src="https://mc.yandex.ru/metrika..."></script> 
  <!-- Свои скрипты -->
  <script src="./script1.js" defer></script>
  <script src="./script2.js" defer></script>
</head>
```

---
layout: iframe-right
url: html/html-form.html
---

# HTML-формы

> HTML-формы нужны для сбора и передачи данных от пользователя, которые можно отправить на сервер (об этом позже) или обработать при помощи JavaScript. Они являются ключевым элементом интерактивных веб-приложений

---

<style scoped>
  li, blockquote {
    font-size: 16px;
    line-height: 1.5rem;
  }

  blockquote {
    margin-top: 12px;
  }
</style>

# HTML-Формы

Основные элементы форм

- `<form>` - контейнер формы, хранит и отправляет все данные
- `<label>` - подпись для элемента. Можно указать `id` соответствующего элемента формы в атрибуте `for`, тогда при клике на подпись браузер автоматически сфокусируется на элементе
- `<fieldset>` - элемент, группирующий элементы в формы в блок. При помощи `<legend>` внутри него можно задать заголовок для группы полей
- `<input>` - поля ввода: текст, email, пароль, чекбоксы и т.п. Можно указать вид поля при помощи атрибута `type`
- `<textarea>` - поле для ввода длинного текста
- `<select>` и `<option>` - выбор из списка
- `<button type="submit">` или `<input type="submit">` - элементы-кнопки для отправки формы

> Все поля ввода должны иметь атрибут `name`. Это название, которое будет использоваться в объекте, хранящем значения формы

---

# HTML-формы

<style scoped>
  li, blockquote {
    font-size: 16px;
    line-height: 1.5rem;
  }

  blockquote {
    margin-top: 12px;
  }
</style>

Основные атрибуты тэга `<form>`

- `action` - адрес, на который отправляются данные. Его можно не указывать, тогда по умолчанию, если не обработать форму при помоищ JS, при отправке страница просто перезагрузится
- `method` - метод отправки (**GET** или **POST**, об этом тоже позже)  
- `novalidate` - форма не будет валидироватсья при отправке
- `enctype` - тип кодирования данных при отправке 
- `autocomplete` (`on` и `off`) - контроль автозаполнения полей браузером (например, браузер может подсказывать email'ы, которые вы вводили на других сайтах)

> **P.S.** Под "отправкой формы" подразумевается заврешение её заполнения и какое-то последующее действие со всеми значениями (обычно отправка на сервер)

---

<style scoped>
  div {
    --slidev-code-font-size: 10px;
    --slidev-code-line-height: 12px;
  }
</style>

# HTML-формы

Обработка при помощи JS

- Все формы на странице хранятся в специальной коллекции - `document.forms`
- Объект с данными формы можно получить, передав элемент формы в `new FormDate(...)`, значения будут храниться в свойстве `values`
- При отправке формы (нажатии на `<button type="submit">`) создаётся событие `'submit'`

<div class="grid grid-cols-2 gap-2">

```html
<form>
  <label for="name">Имя</label>
  <input id="name" name="name" placeholder="Введите имя..." />

  <br />

  <label for="age">Возвраст</label>
  <input id="age" name="age" type="number" min="0" max="120" />

  <p>Пол</p>
  <label><input type="radio" name="gender" value="male" /> Мужской</label>
  <label><input type="radio" name="gender" value="female" /> Женский</label>

  <br />

  <button type="submit">Отправить</button>
</form>
```

```js
const form = document.querySelector('form');

form.addEventListener('submit', e => {
  // Отменяет стандартное поведение при отправке
  // иначе страница перезагрузится
  e.preventDefault();

  console.log(`Форма отправлена!`);

  const formData = new FormData(e.target);
  const formValues = Object.fromEntries(formData);

  console.log(`Значения формы: ${JSON.stringify(formValues)}`);
});
```

</div>

---

<style scoped>
  h3 {
    font-weight: 700;
  }

  li, p:not(h1 + p) {
    font-size: 12px;
    line-height: 1.1rem;
    margin: 4px 0;
  }

  blockquote {
    margin: 8px 0;
  }
</style>

# HTML-формы

Валидация

> **Валидация** - процесс проверки корреткости каких-то данных. В случае форм - проверка введённых пользователем данных

Валидировать формы можно двумя способами - посредством специальных HTML-атрибутов (это называется **нативной валидацией**) или при помощи JS вручную

### Атрибуты валидации

- `required` - обязательность поля
- `minlength`, `maxlength` - ограничение длины текста
- `type="email"`, `type="url"` и некоторые другие - проверка соответствия определённому формату
- `pattern` - проверка соответствия регулярному выражению (о них на одном из следующих слайдов)
- `min`, `max` - вхождение числа в диапазон
- и другие

> В случае валидации при помощи атрибутов, сообщения об ошибках автоматически формируются и отображаются браузером

```html
<input type="email" required placeholder="Введите email">
```

> Также напомню, что у элементов форм есть псевдоклассы `:valid` и `:invalid`. Хорошей практикой считается менять стили элементов в зависимости от их состояния, например невалидному инпута можно добавить красную рамку

---

<style scoped>
  h3 {
    font-weight: 700;
  }
</style>

# HTML-формы

Валидация

### JS для работы с нативной валидацией (Constraint Validation API)

- `element.checkValidity()` - проверка валидности (правильности)
- `element.setCustomValidity('<message>')` - установка собственного сообщения об ошибке
- `element.validity` - объект, хранящий состояние валидации различных правил

```js
const form = document.querySelector('form');
const email = form.querySelector('input[type="email"]');

form.addEventListener('submit', function(event) {
  if (!email.value.includes('@')) {
    email.setCustomValidity('Некорректный email');
    event.preventDefault();
  } else {
    email.setCustomValidity('');
  }
});
```

---
src: ./_shared.md#3
---

---
src: ./_shared.md#4
---

---
layout: cover
---

# Практика по регулярным выражениям

https://regexone.com/

---

<style scoped>
  li, p {
      font-size: 13px;
      line-height: 1.2rem;
      margin: 4px 0;
  }
</style>

# `window.location`

> Объект `location` содержит информацию о текущем адресе страницы - **URL (Uniform Resource Locator)**, и позволяет им манипулировать. Адрес страницы состоит из нескольких компонентов:

<iframe src='https://7d0f4cd8585800bb24b273fa06b90393cc7b2938.mdnplay.dev/en-US/docs/Web/API/Location/runner.html?uuid=7d0f4cd8585800bb24b273fa06b90393cc7b2938&state=hVTtbtowFH2VK3eVQCJAuyFVbkk1adP%2B7A2WSXWSS%2BLh%2BGbO5asV7z45JhAoWn8gdI%2FvxznnOn4TJVdGSPHU1MqCzueJKB0uEgGs2eAxTCxA3Esipwtte2kd4BPPU2tHTBmZXvIJikvmupFPE58fTyZtXegBBzrUcNcWTqzO0P44f2JVhX0JRyjGrapqg2NyxWGmPBt5GFqT67U%2Fjb3E44fpwzQ0OnHphb3gzBLF5QXHExRPFkSTVLnrtQ0ql5W9yg6In%2F%2FOU%2FV6vapUTb8mhPFNqmznQ1cXJ1aMRNY0QraXA958r1w3tVE7CaxSg48e2uicSwl30%2BntY2L3iU1sSvnuWn6UoTFtEeOWI2V0YSVkaBldC6%2FRsc6U6Y4qneeHMQuyHC1Upc1OQiJ%2BILlCq0ScDhv9ihLuAw8Aoy1GJeqiZAl3WAWypWaMmlplKMHSxqm6I%2F2rNeV34F1To1mTleDQKNbrQOIoR9u2fWooW7YnKW09AW0LCSm5HF2U0vY9kfsDkWzlGnISatJH9RkZDxVO7S5ISZnighwGchlZRssSFLMbtBnD9x5VZKkV%2BnguSKUNmRUHmKk%2Bru5ylQAGFyxhdogq5QptowBGHdqzfnbV%2BfEsGKSyZeFoZXMJqVGtbWcSS1qj64SOEitZuQL5XPq1LkfjdmgMbS73edXCg5Ygfzxrl3Kt6uPqzx%2FWftzjyxUGwY%2BTD%2F%2B9l6%2BRtjluJdy1Ia3Y78BvBCtoyOgcXJEO7mcz6H4TeJjeDsNQMRJ%2F%2FHeeU7aq0PLYf8Bjleff12j5p24YLbpBIjKjs2UiRjBAfzKEeRx4teG4du3%2FN1yoleGB7x6ulc1pMzaUKc997F8dmB9qgjqPfWV2Ol0xDhKh80QMw9v5DC83n97Okgvkd8n7l5DuH4f2Vdj78WIkuMQKvTjllmL%2FDw%3D%3D' width="100%" />

- `location.href` - полный адрес страницы
- `location.origin` - источник, содержащий протокол, домен и порт. По нему, например, определяется, к какому сайту хранит данные `localStorage`
- `location.protocol` - протокол, по которому открыта страница (о протоколах тоже позже будет говорить подробнее)
- `location.hostname` - домен
- `location.port` - порт, **опционален**
- `location.host` - значение хоста, содержит домент и порт
- `location.pathname` - текущий путь на сайте, т.е. всё то, что идёт после 1-го `/`. **Опционален**, по умолчанию равен `/` 
- `location.search` - параметры запроса (search query) в формате `ключ1=значение1&ключ2=значение2`, **опциональны**
- `location.hash` - якорная ссылка, указывающая на элемент с соответствующим атрибутом `id`. Не передаётся на сервер

---

<style scoped>
  li {
    font-size: 14px;
    line-height: 1.3rem;
  }

  blockquote {
    margin: 4px 0;
  }
</style>

# `window.history`

> Объект `history` предоставляет методы и свойства для управления историей браузера, позволяя изменять URL и навигацию без перезагрузки страницы

### Свойства и методы

- `history.length` — количество записей в истории текущей вкладки 
- `history.state` — текущее состояние, связанное с записью истории
- `history.back()` — перейти на предыдущую страницу  
- `history.forward()` — перейти на следующую страницу  
- `history.go(n)` — перейти на `n` шагов назад или вперед  
- `history.pushState(state, title, url)` — добавить запись в историю без перезагрузки  
- `history.replaceState(state, title, url)` — заменить текущую запись истории

> `state` - произвольный объект, который можно связать с конкретной страницой

```javascript
// Добавление новой записи в историю
history.pushState({page: 2}, "Page 2", "?page=2");

// Обработка события изменения истории (не работает с pushState и replaceState)
window.addEventListener('popstate', event => {
  console.log("Текущее состояние:", event.state);
});
```

---
transition: none
---

# Клиентская маршрутизация

> **Маршрутизация (Routing)** - определение того, что должно отображать приложение в зависимости от текущего адреса. Клиентская маршрутизация, соответственно, - это когда логика маршрутизации определяется в клиентском приложении (прямо в браузере), а не на сервере (про сервершую маршрутизацию будем говорить позже)

Самый простой подход к клиентской маршрутизации - создание отдельных `.html` файлов для каждой страницы. В таком случае навигация осуществляется при помощи ссылок (`<a href="...">`), а путь (`pathname`) будет соответствовать пути до файла компьютере (`index.html` соответствует пустому пути):

```
index.html             # /
profile.html           # /profile
pages
  index.html           # /pages
  blog-post-1.html     # /pages/blog-post-1
```

---

<style scoped>
  p, li {
    font-size: 13px;
    line-height: 1.2rem;
  }

  blockquote {
    margin-top: 12px;
  }
</style>

# Клиентская маршрутизация

<div class="grid grid-cols-2 gap-2">

<div>

Альтернативой является маршрутизация при помощи JS - когда контент страницы меняется динамически в засимости от текущего состояния url. Его основное преимущество в том, что навгиация происходит намного более плавно, нет необходимости загружать целую страницу заново

Общая его суть такова:
1. Пользователь кликает на ссылку или кнопку  
2. JavaScript перехватывает событие и изменяет URL при помощи `history.pushState()` или `history.replaceState()`
3. В зависимости от URL приложение определяет, что должно отображаться на странице
4. Также необходимо обработать событие `popstate`, чтобы приложение корретно работало при навигации "назад/вперёд"

> **P.S.** Такой подход называется **SPA (Single Page Application)**. На текущий момент это самый распространённых подход в веб-разработке, реализованный во множестве инструментов, которые мы будем изучать позднее

</div>

```js
const anchors = document.querySelectorAll('a');

const render = path => {
  // Что-то делаем в зависимости от пути
  // Например, заменяем контент страницы
};

anchors.forEach(a =>
  a.addEventListener('click', e => {
    // Отмена стандартного перехода по ссылке
    e.preventDefault();

    const path = e.target.getAttribute('href');

    history.pushState({ path }, '', path);
    render(path);
  })
);

// Обаботка кнопок 'Назад/Вперёд' в браузере
window.addEventListener('popstate', e => {
  const path = e.state?.path;
  render(path);
});
```

</div>

---

<style scoped>
  li {
    font-size: 14px;
    line-height: 1.3rem;
  }
</style>

# Практика

<div></div>

Доработайте проект "[Генератор паролей](https://github.com/FloydanTheBeast/hse-lyceum-web-2025/tree/main/snippets/frontend/password-generator)" (за основу можете взять проект по ссылке):
- Сделайте так, чтобы при нажатии на кнопку "Сгенерировать" отправлялась форма
- Добавьте валидацию того, что пользователь выбрал по крайней мере один набор символов и выведите ошибку, если это не так
- Добавьте вторую страницу с регистрацией (**конечно же пока не настоящей**). Можете ориентироваться на <b>[макет в Figma](https://www.figma.com/design/3x7yn1qeD284llZFgTOSKV/%D0%A1%D1%82%D1%80%D0%B0%D0%BD%D0%B8%D1%86%D0%B0-%D1%80%D0%B5%D0%B3%D0%B8%D1%81%D1%82%D1%80%D0%B0%D1%86%D0%B8%D0%B8?node-id=0-1&t=olO8z8xaVl0bdfDR-1)</b>, попытайтесь сделать красиво :) (но конечно не обязательно)
  - Попробуйте реализовать маршрутизацию при помощи JS
  - Правила валидации:
    - Имя и фамилия могут содержать только буквы и должны начинаться с заглавной (воспользуйтесь регулярными выражениями)
    - Email должен быть правильным
    - Номер телефона должен быть в таком же формате, как на макете (тоже регулярка)
    - Пароли должны совпадать, не должны содержать пробелов и должны содержать минимум 10 символов
    - Обязательно должно быть дано согласие с пользовательскими соглашениями
  - При нажатии на кнопку "Зарегистрироваться":
    - Выводятся ошибки валидации, если в полях содержатся ошибки
    - Происходит навигация на страницу генерации пароля, если всё введено верно
  

---
src: ./_shared.md#1
---

---

# Дополнительные материалы

- [Skillbox Media - HTML <​form​>: тег для создания форм, его атрибуты, методы отправки данных](https://skillbox.ru/media/code/html-form-teg-dlya-sozdaniya-form-ego-atributy-metody-otpravki-dannyh/)
- [MDN - Валидация ограничений](https://developer.mozilla.org/ru/docs/Web/HTML/Guides/Constraint_validation)
- [Regex101](https://regex101.com/) - онлайн-среда для написания, объяснения работы и тестирования регулярных выражений
- [Doka - `window.history`](https://doka.guide/js/window-history/)