---
theme: default
title: Основы фронтенд-разработки / Курс по веб-разработке, 10 класс
class: text-center
drawings:
  persist: false
transition: slide-left
mdc: true
fonts:
  sans: Montserrat
hideInToc: true
browserExporter: true
---

# Курс по веб-разработке

<h2 class="color-gray-400 fw-200">Основы фронтенд-разработки</h2>

---

# CSS

<style scoped>
  li p {
    margin: 8px 0;
    font-size: 16px;
    line-height: 1.2rem;
  }
</style>

Позиционированние

> **Позиционирование** (свойство `position`) контролирует то, каким образом задаётся расположение элемента на странице. Для перемещения элемента используются дополнительные свойства: `top`, `right`, `bottom`, `left` и `inset`.

- `static` - значение по умолчанию для любого элемента. С этим значением они располагаются в **нормальном потоке** согласно **контексту форматирования** родительского элемента (то есть в зависимости от того, является ли он блочным, строчным или строчно-блочным)

- `relative` - то же, что и статичное расположение, но элемент может быть смещён относительно своего начального положения. При этом смещение будет исключительно визуальным, то есть "блок" элемента на самом деле останется там же, где и был, соседних элементов это не коснётся

- `absolute` - элемент позиционируется относительно ближайшего родительского элемента, чьё позиционирование в свою очерень отличается от `static`

- `fixed` - элемент позиционируется относительно окна браузера

- `sticky` - элемент изначально позиционируется как статичный, но при прокрутке родителя фиксируется ("прилипает")

---
layout: iframe-right
url: html/position-relative.html
---

# CSS

Относительное (`relative`) позиционирование

Элементы смещаются только визуально, но с одним исключением: если он выходит за пределы родительского элемента, то появляется скролл

---
layout: iframe-right
url: html/position-absolute.html
---

<style scoped>
  li {
    margin-bottom: 4px;
    font-size: 14px;
    line-height: 1.1rem;
  }
</style>

# CSS

Абсолютное (`absolute`) позиционирование

- Позиционирование задаётся относительно (левого верхнего угла) ближайшего **позиционированного**, т.е, чей `position` отличается от `static`, родительского элемента - **опорного**
- Элемент убирается из основного потока документа, то есть перестаёт влиять на положение окружающих элементов и на размер родителя. Для простоты можно представить, что элемент уходит на слой выше и перестаёт взаимодействовать со всеми элементами, кроме собственных потомков.
- Если элемент был частью строчного контекста форматирования, он приобретает блочный контекст форматирования
- Если элемент был блочным и занимал всю ширину своего родителя, то теперь его ширина будет определяться шириной контента
- Внешние отступы (`margin`) не схлопываются с соседними элементами

---
layout: iframe-right
url: html/position-fixed.html
---

<style scoped>
  li {
    margin-bottom: 4px;
    font-size: 16px;
    line-height: 1.2rem;
  }
</style>

# CSS

Фиксированное (`fixed`) позиционирование

- Элемент убирается из основного потока документа, то есть перестаёт влиять на положение окружающих элементов и на размер родителя. Для простоты можно представить, что элемент уходит на слой выше и перестаёт взаимодействовать со всеми элементами, кроме собственных потомков.
- Элемент позиционируется относительно окна браузера, за исключением случаев, если один из родителей имеет значения свойств `transform`, `perspective` или `filter`, отличные от `none`. В этом случае блок становится **опорным**, и позиционирование будет производиться уже относительно него, а не окна браузера.

---
layout: iframe-right
url: html/position-sticky.html
---

<style scoped>
  li {
    margin-bottom: 4px;
    font-size: 16px;
    line-height: 1.2rem;
  }
</style>

# CSS

Липкое (`sticky`) позиционирование

- Элемент ведёт себя как элемент с относительным (`relative`) позиционированием до тех пор, пока его родитель не будет прокручен до определённой границы. Как правило, эта точка совпадает с положением верхней границы нашего элемента, но может быть изменена с использованием свойства `top`.
- Элемент остаётся "приклеенным" во время прокрутки родителя до тех пор, пока не "встретит" противоположную границу своего родителя.

---
layout: iframe-right
url: html/z-index.html
---

<style scoped>
  li {
    margin-bottom: 4px;
    font-size: 16px;
    line-height: 1.2rem;
  }
</style>

# CSS

Наложение слоёв - свойство `z-index`

- Свойство `z-index` позволяет управлять порядком наложения элементов друг на друга, то есть по сути расположение по оси `z`
- Может быть отрицательным или положительным числом
- Его можно задавать только для **позиционированных** элементов
- По умолчанию элемент, находящийся ниже по дереву, будет отображаться "над" элементами, находящимися сверху
- Значением по умолчанию является `auto`

---
layout: iframe-right
url: https://doka.guide/css/flexbox-guide/demos/flex-demo/order/
class: iframe-zoom-70
---

<style scoped>
  iframe {
    max-height: 100%;
    zoom: 0.5;
  }

  li {
    margin-bottom: 4px;
    font-size: 16px;
    line-height: 1.2rem !important;
  }
</style>

# CSS - Flexbox

> **Флексбокс** (flexbox, от англ. flex - гибкий) - способ отображения, позволяющий "гибко", то есть всячески настраиваемо, располагать элементы внутри контейнера

Устанавливается при помощи свойства `display: flex`

#### Основные определения
- **Флекс-контейнер** - элемент, для которого установлено свойство `display: flex`
- **Флекс-элемент** - дочерний элемент флексбокса
- **Основная ось** - основная направляющая прямая флекс-контейнера, вдоль которой располагаются флекс-элементы
- **Побочная ось** - перпендикуляр основной оси

---

<style scoped>
  li {
    margin-top: 4px;
    font-size: 12px;
    line-height: 1.1rem;
  }
</style>

# CSS - Flexbox

Свойства флекс-контейнера

- `flex-direction` - задаёт направление основной оси
  - `row` (по умолчанию) - горизонтально слева направо
  - `row-reverse` - горизонтально справа налево
  - `column` - вертикально сверху вниз
  - `column-reverse` - вертикально снизу вверх
- `flex-wrap` - могут ли элементы быть перемещены в следующую ряд (или столбец), если не помещаются в контейнер
  - `nowrap` (по умолчанию) - не могут быть перемещены, будут пытаться влезть в один ряд (или стобец)
  - `wrap` - могут быть перемещены
  - `wrap-reverse` - изначально будут располазаться снизу вверх (или справа налево) и перемещаться в обратном направлении
- `flex-flow` - быстрый способ одновременно задать `flex-direction` и `flex-wrap`, например: `flex-flow: column nowrap`
- [`justify-content`](https://developer.mozilla.org/ru/docs/Web/CSS/justify-content) - выравнивание элементов по основной оси
- [`align-items`](https://developer.mozilla.org/ru/docs/Web/CSS/align-items) - выравнивание элементов по побочной оси
- [`align-content`](https://developer.mozilla.org/ru/docs/Web/CSS/align-content) - отвечает за распределение свободного места между рядами (столбцами) по побочной оси
- `gap` - отступы между строками и стобцами, краткая запись для `row-gap` и `column-gap`

<style scoped>
  li {
    margin-top: 4px;
    font-size: 14px;
    line-height: 1.1rem;
  }
</style>

---

<style scoped>
  li {
    margin-top: 4px;
    font-size: 16px;
    line-height: 1.25rem;
  }
</style>

# CSS - Flexbox

Свойства флекс-элемента

- `flex-grow` - числовое свойство, указывающая на то, может ли элемент увеличиваться в размере при наличии свободного пространства и на сколько, по умолчанию равен `0`. Если у всех элементов `1`, то пространство будет распределено равномерно, если одному из них при этом указать `2`, то он попытается занять в 2 раза больше места, чем остальные
- `flex-shrink` - противоположно `flex-grow`. Если в контейнере не хватает места, то элемент может уменьшиться. По умолчанию равно `1`
- `flex-basis` - базовый размер элемента
- `flex` - свойство для быстрой установки `flex-grow`, `flex-shrink` и `flex-basis`, например: `flex: 1 0 auto`
- `align-self` - индивидуально выравнивание элемента, замещающее родительский `align-items`

---
layout: cover
---

# Практика по flexbox

https://leaderflex.netlify.app/#ru

---

<style scoped>
  h3 {
    margin: 8px 0;
  }

  li {
    margin-top: 4px;
    font-size: 16px;
    line-height: 1.25rem;
  }
</style>

# CSS

Цвета

### Способы задания

- **По названию цвета** - например `black`, `white`, `blue`, `green` и т.п.
- **RGB (Red, Green, Blue)** - модель, в которой указывается "количество" красного, зелёного, и синего цветов значениями от **0 до 255**, называющихся **каналами**. Задаётся **css-функцией** `rgb`, например: `color: rgb(55, 255, 100)`. Также есть функция `rgba`, добавляющая четвёртый альфа-канал - прозрачность, принимающая значение от 0 до 1, например: `background-color: rgba(55, 255, 100, 0.5)`
- **HEX** - шестнадцатиричный код цвета в модели RGB, начинается с символа `#`. Каждому каналу соответствует 2 цифры числа, например: `color: #38ff64`. Если обе цифры во всех каналах одинаковые, то можно писать кратко: `#012` (= `#001122`). Для альфа-канала добавляется ещё две цифры, например: `#38ff6480`
- **HSL**, **OKLCH**, **HWB**, **HSV** - про них можете почитать сами :)

### Полезные значения

- `transparent` - полностью прозрачный цвет
- `currentColor` - равняется цвету текста элемента

---
transition: none
---

<style scoped>
  h3 {
    margin: 8px 0;
  }

  li {
    margin-top: 4px;
    font-size: 16px;
    line-height: 1.25rem;
  }
</style>

# CSS

Единицы измерения

### Длина и расстояние

- **Абсолютные** - привязаны к физическим единицам измерения
  - `px` - пиксели, равняются 1/96 дюйма
  - `cm` - сантиметры
  - `in` - дюймы
  - `mm` - миллиметры
  - ...

<div class="mt-4">

> Существуют экраны с разной плотностью пикселей и разными разрешениемя, поэтому соотношение единиц измерения к точкам экрана утратило прежний смысл. Сантиметры и дюймы при выводе на экран **не будут** соответствовать своим реальным размерам

</div>

---

<style scoped>
  h3 {
    margin: 8px 0;
  }

  li {
    margin-top: 4px;
    font-size: 14px;
    line-height: 1.2rem;
  }
</style>

# CSS

Единицы измерения

- **Относительные**
  - **em** - размер относительно шрифта элемента, например если размер шрифта - `10px`, то `2em = 20px`
  - **rem** - размер относительно шрифта корневого элемента, для веб-страницы это тэг `<html>`
  - **vh (viewport height)** - размер относительно высоты viewport'а (области просмотра), `1vh` - 1% от высоты
  - **vw (viewport width)** - размер относительно ширины viewport'а
  - **vmin (viewport min)** - размер относительно меньшей стороны viewport'а
  - **vmax (viewport max)** - размер относительно больше стороны viewport'а
  - ...

### Разное
- `deg` - градусы угла
- `grad`, `rad` - градианы и радианы
- `turn` (оборот) - какая-то часть окружности, например `0.25turn` - 90 градусов
- `ms`, `s` - миллисекунды и секунды
- `dpi`, `dpcm`, `dppx` (dots per inch/cantimeter/pixel) - плотность пикселей в точках на дюйм/сантиметр/пиксель
- **Проценты** - доля от какой-то другой величины, например `width: 50%`

---

<style scoped>
  h3 {
    margin-bottom: 8px;
  }

  li {
    margin-top: 4px;
    font-size: 14px;
    line-height: 1.2rem;
  }
</style>

# CSS

Функции и переменные

<div class="grid grid-cols-2 gap-4">

<div>

### Функции

- `min`, `max` - минимум и максимум из двух значений
- `calc` - высиление математического выражения, например: `calc(100% / 3 + (24px * 2))`
- `attr` - получение значения HTML-атрибута
- `transform` - преобразования элемента, подробнее в следующий раз
- `filter` - графические эффекты, подробнее в следующий раз
- `rgb`, `rgba`, `hsl`, `oklch`, ... - задание цвета
- `url` - использование файла по заданному url

... и ещё множество других

</div>

<div>

### Переменные

> Переменные ищутся **только вверх по дереву**, а не по всему документу

```css
/* Глобальные переменные */
:root {
  --color-primary: #555;
  --gap-4: 4px;
  --font: 'Roboto', sans-serif;
}

/* Локальные переменные */
.some-class { ... }

/* Использование переменных */

a {
  color: var(--color-primary);
}
```
</div>

</div>

---
transition: none
---

# JavaScript

Область видимости

> **Область видимости (Scope)** - это та часть программы (область, зона), в которой доступна переменная или функция

```js {all|4-9|13}
const a = 1;
console.log(a); // 1

function fn() {
  const b = 2;

  console.log(b) // 2
  console.log(a) // 1
}

console.log(fn) // function fn() {[native code]}

console.log(b) // Uncaught ReferenceError: b is not defined
```

---
transition: none
---

# JavaScript

Блочная область видимости

Область видимости внутри блока кода, например:
- `if() {}`
- `for(const ... of ...) {}`
- `while() {}`
- `{}` - самостоятельная область видимости

```js
for (const color of ['green', 'red', 'blue']) {
    // область видимости блока for
    const message = 'Hi'
    console.log(color) // 'green', 'red', 'blue'
    console.log(message) // 'Hi', 'Hi', 'Hi'
}

console.log(color) // ReferenceError
console.log(message) // ReferenceError
```

---
transition: none
---

# JavaScript

Область видимости функции

Функции создают собственную область видимости, соответственно все переменные, объявленные внутри функции, доступны только внутри неё и во вложенных функциях/блоках

```js
function run() {
    // Область видимости функции run()
    let one = 1
    function run2() {}
    var run3 = () => {
      console.log(one, run2) // 2 1 function run2() {[native code]}
    }

    console.log(one)
    console.log(run2)
    console.log(run3)
}

run() // 1 ƒ run2() {} () => {}
console.log(one) // ReferenceError
console.log(run2) // ReferenceError
console.log(run3) // ReferenceError
```

---

# JavaScript

Глобальная область видимости

> Глобальная область видимости является самой внешней областью. Она доступна для любой внутренней или локальной области видимости. В браузере глобальной является область видимости, создаваемая при загрузке JavaScript-файла, указанного в атрибуте `src` тега `<script>`

Переменные, объявленные в глобальной области видимости являются глобальными переменными. Они доступны в **любой другой области.**

Глобальная область видимости, помимо прочего, — это механизм, который позволяет среде выполнения JavaScript-кода (браузеру, Node.js или другой) предоставлять приложениям хостовые (т.е. принадлежащие среде) объекты как глобальные переменные. Например, `window` и `document` являются глобальными переменными (объектами), предоставляемыми браузером. В Node.js такой переменной является, например, объект `process`.

---
transition: none
---

# JavaScript

Поднятие

<div class="flex flex-col gap-4">

> **Поднятие (Hoisting)** - это поведение, при котором функцию или переменную можно использовать до объявления

```js
console.log(test); // Ошибки тут не будет
var test;
```

> Классическое (**неверное**) объяснение - поднятие предполагает, что объявления переменных и функций физически перемещаются в начало кода — "поднимается". Но это не так: интерпретатор JS никак не меняет структуру кода и не анализирует последующий код для нахождения объявления переменной. На самом деле, перед интерпретацией кода работает парсер, который как бы "запоминает" список объявленных переменных

</div>

---

<style scoped>
  div.grid-cols-2 p {
    font-size: 12px;
    line-height: 1rem;
    margin: 4px 0;
  }

  .grid-cols-2 blockquote {
    margin-bottom: 16px;
  }
</style>

# JavaScript

Поднятие

<div class="grid grid-cols-2 gap-4">

<div>

Поднятие работает только с `var`, а при обращении к `let` и `const` до инициализации срабатывает механизм **TDZ - Temporal Dead Zone** и выбрасывается исключение `ReferenceError`

> На самом деле, `let` и `const` тоже поднимаются. Разница в том, что на этапе планирования компиляции `var` инициализируется как `undefined`, а `let` и `const` инциализируются только тогда, когда в процессе интерпретации мы приходим к декларации переменной в текущем блоке.

```js
	teacher = "Shadi" // Uncaught ReferenceError: Cannot access 'teacher' before initialization
	let teacher
```

</div>

<div>

Не поддерживается инициализация:

```js
console.log(a); // вывод: undefined
var a = 5;
```

Функции также подвержены поднятию, притом её можно вызвать и она сработает:

```js
greet();

function greet() {
    console.log('Hello');
}
```

При этом функциональные выражение (так как по сути являются переменными и не инициализируются) не поднимаются:

```js
greet(); // Uncaught ReferenceError: a is not defined
let greet = function() { console.log('Hello'); }
```

</div>

<div>
</div>

<div>
</div>

</div>

---

<style scoped>
  div.grid-cols-2 p {
    font-size: 12px;
    line-height: 1rem;
    margin: 4px 0;
  }

  .grid-cols-2 blockquote {
    margin-bottom: 16px;
  }
</style>

# JavaScript

Различия `var`, `let` и `const`

<div class="grid grid-cols-2 gap-4">

<div>

`var` - имеет область видимости на уровне функции, но не блочную.

> Это может привести к непреднамеренной перезаписи данных и к другим ошибкам. В целом, переменная должна иметь область видимости, ограниченную её нуждами, но не превышающую их

```js
function varTest() {
  for (var i = 0; i < 3; i++) {
    console.log(i);
  }

  // Выведет 3, так как
  // var i создаст переменную на уровне функции
  console.log(i);
}

varTest();
```
</div>

<div>

`let` и `const` - имеют область видимости на уровне блока

```js
function letTest() {
  for (let i = 0; i < 3; i++) {
    console.log(i);
  }

  // Uncaught ReferenceError: i is not defined
  console.log(i);
}
```

</div>

</div>

Также различается процесс поднятия, о котором мы говорили на прошлом слайде

---
layout: cover
---

# Практика по вёрстке

---
layout: iframe
url: html/challenge.html
---

---
src: ./_shared.md#1
---

---

# Дополнительные материалы

## CSS
- [Doka - Гайд по flexbox](https://doka.guide/css/flexbox-guide/)
- [Песочница для понимания flexbox](https://ui-catalog.vercel.app/flexbox-playground)
- [Шпаргалка по flexbox](https://yoksel.github.io/flex-cheatsheet/)
- [MDN - CSS Value Functions](https://developer.mozilla.org/en-US/docs/Web/CSS/CSS_Values_and_Units/CSS_Value_Functions) (документация про CSS-функции)
