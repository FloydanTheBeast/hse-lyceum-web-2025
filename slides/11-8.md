---
theme: default
title: "SQL: DDL, Constraints, DML, DQL / Курс по веб-разработке, 11 класс"
class: text-center
drawings:
  persist: false
transition: slide-left
mdc: true
fonts:
  sans: Montserrat
hideInToc: true
browserExporter: true
---

# Курс по веб-разработке

<h2 class="color-gray-400 fw-200">SQL: DDL, Constraints, DML, DQL</h2>

---

# Рекурсивные запросы

<div></div>

Рекурсивные запросы позволяют запросить иерархические данные, то есть те, в которых есть несколько "уровней" вложенности связей, например: иерархия сотрудников, дерево категорий (товаров, фильмов или чего угодно ещё)

```sql
WITH RECURSIVE recursive_table AS (
    -- Базовый запрос (anchor)
    SELECT ...
    FROM ...
    WHERE ...

    -- Оператор объединения результатов нескольких запросов
    -- важно, чтобы совпадали столбцы в обоих результатах
    UNION ALL

    -- Рекурсивная часть
    SELECT ...
    FROM recursive_table
    JOIN ...
    -- Тут уже можно использовать результат рекурсивного запроса
    -- в данном случае - recursive_table
    ON ...
)
SELECT * FROM recursive_table;
```

---
transition: none
---

# Оконные функции

> **Оконная (или аналитическая) функция (window function)** в SQL - это функция, использующая значения из одного или нескольких строк таблицы и **возвращает значение для каждой строки** (в противоположность агрегирующим функциям, возвращающим единственное значение для нескольких строк). Оконные функции используют ключевое слово `OVER`; если оно не используется, то функция считается скалярной (для одной строки) или агрегирующей

### Общий синтаксис

```
SELECT 
	column_name1, 
	window_fn(column_name2) [FILTER (WHERE filter_clause)] OVER([PARTITION BY column_name1] [ORDER BY column_name3]) AS new_column  
FROM table_name;
```

### Классы функций

- Агрегирующие (`AVG, COUNT, MAX, MIN, SUM`)
- Ранжирующие (`RANK, DENSE_RANK, NTILE, ROW_NUMBER, CUME_DIST`)
- Функции смещения (`FIRST_VALUE, LAST_VALUE, LAG, LEAD, NTH_VALUE`)

---

<style scoped>
  p {
    font-size: 12px;
    line-height: 1.1rem;
  }

  div {
    --slidev-code-font-size: 10px;
    --slidev-code-line-height: 12px;
  }
</style>

# Оконные функции

> Ключевое слово `PARTITION BY` группирует строки в **партиции (части)** и функция применяется для каждой таковой отдельно. Если `PARTITION BY` пропущено, то весь результат считается единственной партицией

> Оконные функции рассчитываются **после агрегации** (например после `GROUP BY`)

> Оконные функции позволяют получить доступ к данным перед и после текущей записи. Они определяют окно или фрейм заданной длины вокруг текущей записи и выполняют расчёт на основании данных из окна

<div class='grid grid-cols-2 gap-2 mt-1'>

<div>

```sql
SELECT
  c.CustomerId,
  c.FirstName || ' ' || c.LastName AS CustomerName,
  SUM(i.Total) AS TotalSpent,
  RANK() OVER (ORDER BY SUM(i.Total) DESC) AS SpendingRank,
  DENSE_RANK() OVER (ORDER BY SUM(i.Total) DESC) AS DenseRank
FROM Customers c
JOIN Invoices i ON c.CustomerId = i.CustomerId
GROUP BY c.CustomerId
ORDER BY SpendingRank;
```

```sql
SELECT
    a.Title AS Album,
    t.Name AS Track,
    t.Milliseconds / 1000 AS DurationSec,
    RANK() OVER album_tracks AS RankInAlbum
FROM Tracks t
JOIN Albums a ON t.AlbumId = a.AlbumId
WINDOW album_tracks AS (PARTITION BY a.AlbumId ORDER BY t.Milliseconds DESC)
ORDER BY a.Title, RankInAlbum;
```

</div>

<div>

```sql
SELECT
    i.CustomerId,
    c.FirstName || ' ' || c.LastName AS CustomerName,
    i.InvoiceId,
    i.Total,
    ROUND(AVG(i.Total) OVER (PARTITION BY i.CustomerId), 2) AS AvgPerCustomer,
    ROUND(i.Total - AVG(i.Total) OVER (PARTITION BY i.CustomerId), 2) AS Deviation
FROM Invoices i
JOIN customers c ON c.CustomerId = i.CustomerId
ORDER BY i.CustomerId, i.InvoiceDate;
```

```sql
SELECT
  LAG(FirstName, 1)
    OVER(ORDER BY FirstName) AS prev,
  FirstName AS current,
  LEAD(FirstName, 1) 
    OVER(ORDER BY FirstName) AS next
FROM employees;
```

</div>
</div>

---

<style scoped>
  li, p {
    font-size: 14px;
    line-height: 1.2rem;
  }

  div {
    --slidev-code-font-size: 12px;
    --slidev-code-line-height: 14px;
  }
</style>

# SQL View

> **SQL View (представление)** - объект базы данных, являющийся результатом выполнения запроса к базе данных, определённого с помощью оператора `SELECT`, в момент обращения к представлению

> Так же называется **виртуальной таблицей**, так как имеет такой же вид, но фактически не хранит данных, а получает их в момент обращения

### Синтаксис создания

```sql
CREATE [OR REPLACE]
VIEW <имя_представления> [(имена_полей_представления)]
AS <select_выражение>
```

### Применение

- **Упрощение сложных запросов** - можно скрыть сложные фильтры, джойны, группировку и т.п. в представление
- **Переиспользование запросов**
- **Безопасность и контроль доступа** - можно ограничить доступ к исходным таблицам, а разрешить работу только с представлениями, чтобы скрыть некоторые поля и/или таблицы
- **Абстрагированность от структуры БД** - код может работать только с представлениями, чтобы в случае изменения структуры таблиц достаточно было бы только соответствующим образом поменять представления
- **Составление отчётов** - представления часто используются как виртуальные отчётные таблицы, например: ежемесячные продажи, рейтинг клиентов и т.п.
- **Ускорение аналитики при помощи материализации** - некоторые СУБД поддерживают периодическое сохранение представлений в таблицы, что позволяет существенно ускорить запросы

---

# SQL View

Пример

```sql
DROP VIEW v_TopTracks IF EXISTS;

CREATE VIEW v_TopTracks AS
SELECT
    t.TrackId,
    t.Name AS TrackName,
    a.Title AS Album,
    ar.Name AS Artist,
    COUNT(ii.InvoiceLineId) AS SalesCount,
    ROUND(SUM(ii.UnitPrice * ii.Quantity), 2) AS Revenue
FROM invoice_items ii
JOIN tracks t ON ii.TrackId = t.TrackId
JOIN albums a ON t.AlbumId = a.AlbumId
JOIN artists ar ON a.ArtistId = ar.ArtistId
GROUP BY t.TrackId
ORDER BY Revenue DESC
LIMIT 10;

SELECT * FROM v_TopTracks;
```

---

<style scoped>
  li, p {
    font-size: 14px;
    line-height: 1.2rem;
  }
</style>

# Индексы

> **Индекс** - это специальная структура данных, содержащая копию данных какого-то столбца или набора столбцов таблицы и указатели на фактическое положение строк, соответствующих этим данным. При этом она устроена (по сути отсортирована) таким образом, чтобы значительно ускорить некоторые операции

### Для чего нужны

- **Ускоряют `SELECT` с фильтрацией** (`WHERE`, `JOIN`) по индексированным столбцам, позволяя обходиться без полного сканирования таблицы (**Full table scan**)
- **Ускоряют `SELECT` с сортировкой** (`ORDER BY`) по индексированным столбцам, так как данные в структуре данных индекса храняться упорядоченными
- **Могут обеспечивать уникальность в случае уникальльных индексов (Unique Indexes)** - соответственно контролируют целостность данных. Для первичных ключей, например, всегда по умолчанию строится уникальный индекс. **Не путать с ограничением `UNIQUE`**! Их различия в следующем:
  - Цель уникального индекса - прежде всего ускорить запросы и только во-вторых - гарантиртировать уникальность; цель ограничения - только гарантировать уникальность
  - Индекс можно строить по выражениям (например, `LOWER(email)`)
  - В некоторых СУБД ограничение `UNIQUE` удаляется только вместе с удалением таблицы, а индекс можно удалить всегда
  > **P.S.** Некоторые СУБД в качестве внутренней реализации для ограничения `UNIQUE` в любом случае используют индекс

---

<style scoped>
  h1 + p {
    margin: 0;
  }

  th {
    padding: 4px 8px;
  }

  td {
    font-size: 12px;
  }
</style>

# Индексы

Виды

| Тип индекса                                           | Описание                                                                       |
| ----------------------------------------------------- | ------------------------------------------------------------------------------ |
| **B-дерево или B+ -дерево (по умолчанию)**            | Наиболее распространённый. Подходит для точного поиска, диапазонов, сортировки |
| **UNIQUE (уникальный)**                               | Обеспечивает **уникальность значений**                                         |
| **Composite (Составной)**                             | Индекс на нескольких столбцах                                                  |
| **Functional/Expression Index (Индекс по выражению)** | Индекс по вычисляемому значению                                                |
| **Partial / Filtered (частичный)**                    | Индекс только на части строк по условию                                        |
| **Full-Text (полнотекстовый)**                        | Для быстрого поиска по длинному тексту                                         |
| **Hash (хеш-индекс)**                                 | Быстрый поиск по точному совпадению, не подходит для диапазонов                |
| **Clustered (кластерный)**                            | Определяет физический порядок строк в таблице. Обычно единственный и автоматически создаётся с первичным ключом     |

---

<style scoped>
  p:not(h1 + p) {
    font-size: 12px;
    line-height: 1.1rem;
  }

  h3 {
    font-size: 16px;
    line-height: 1.4rem;
    font-weight: 700;
  }

  div {
    --slidev-code-font-size: 10px;
    --slidev-code-line-height: 12px;
  }
</style>

# Индексы

Создание (на примере SQLite)

<div class='grid grid-cols-2 gap-2'>

<div class="bg-gray-200 dark:bg-gray-800 p-2 border-rd-4">

### Кластерный

Создаётся автоматически для первичного ключа

</div>

<div class="bg-gray-200 dark:bg-gray-800 p-2 border-rd-4">

### Обычный (B-дерево)

```sql
CREATE INDEX idx_customers_country
ON Customers (Country);
```

</div>
<div class="bg-gray-200 dark:bg-gray-800 p-2 border-rd-4">

### Составной

```sql
CREATE INDEX idx_customers_country_lastname
ON Customers (Country, LastName);
```

</div>
<div class="bg-gray-200 dark:bg-gray-800 p-2 border-rd-4">

### По выражению

```sql
CREATE INDEX idx_lower_full_name
ON Customers (LOWER(FirstName || ' ' || LastName));
```

</div>
<div class="bg-gray-200 dark:bg-gray-800 p-2 border-rd-4">

### Уникальный

```sql
CREATE UNIQUE INDEX idx_unique_email
ON Customers (Email);
```

</div>
<div class="bg-gray-200 dark:bg-gray-800 p-2 border-rd-4">

### Частичный

```sql
CREATE INDEX idx_active_customers
ON Customers (Country)
WHERE Country IS NOT NULL;
```

</div>
</div>

---

<style scoped>
  .node { fill: #ffffff; stroke: #22c55e; stroke-width: 2; }
  .edge { stroke: #22c55e; stroke-width: 2; }
  .label { font: 17px sans-serif; fill: #000; text-anchor: middle; dominant-baseline: middle; font-weight: 600; }
  .title { font: 20px sans-serif; fill: #22c55e; font-weight: 600; }
  .node { fill: #fffdf6; stroke: #264653; stroke-width: 2; rx: 6px; }
  .node-text { font: 14px "Segoe UI", sans-serif; fill: #264653; text-anchor: middle; dominant-baseline: middle; }
  .data-edge { stroke: #e76f51; stroke-width: 1.6; stroke-dasharray: 4 2; marker-end: url(#arrow-data); }
  .record { fill: #fff4e6; stroke: #e76f51; stroke-width: 1.5; rx: 4px; }
  .record-text { font: 11px "Segoe UI", sans-serif; fill: #b85c38; text-anchor: start; dominant-baseline: middle; }
  .sub { font: 16px "Segoe UI", sans-serif; fill: #22c55e; }
  .inner-label { font: 11px "Segoe UI", sans-serif; fill: #3a6ea5; text-anchor: middle; }
  .link { stroke: #f4a261; stroke-width: 2; stroke-dasharray: 4 2; marker-end: url(#arrow-leaf); }

  p:not(h1 + p) {
    font-size: 12px;
    line-height: 1.1rem;
  }
</style>

# Индексы

B и B+ деревья

<div class="grid grid-cols-3 gap-2">

<div class="grid-col-span-2">

> **B и B+ деревья** - самобалансирующиеся отсортированные древовидные структуры, предназначенные для быстрого поиска, вставки и удаления данных на диске. Используются для индексов СУБД и поисковых движковых, а также в файловых системам, так как минимизирует обращения к диску

</div>

<svg viewBox="70 0 760 350" style="margin-bottom: -20px" xmlns="http://www.w3.org/2000/svg">
  <text x="90" y="24" class="title">Сбалансированное дерево</text>
  <text x="520" y="24" class="title">Несбалансированное дерево</text>

  <!-- Balanced tree (left) -->
  <!-- level 0 -->
  <line class="edge" x1="200" y1="60" x2="140" y2="120"/>
  <line class="edge" x1="200" y1="60" x2="260" y2="120"/>
  <line class="edge" x1="140" y1="120" x2="110" y2="180"/>
  <line class="edge" x1="140" y1="120" x2="170" y2="180"/>
  <line class="edge" x1="260" y1="120" x2="230" y2="180"/>
  <line class="edge" x1="260" y1="120" x2="290" y2="180"/>

  <circle class="node" cx="200" cy="60" r="22"/>
  <text class="label" x="200" y="60">8</text>

  <circle class="node" cx="140" cy="120" r="20"/>
  <text class="label" x="140" y="120">4</text>

  <circle class="node" cx="260" cy="120" r="20"/>
  <text class="label" x="260" y="120">12</text>

  <circle class="node" cx="110" cy="180" r="18"/>
  <text class="label" x="110" y="180">2</text>

  <circle class="node" cx="170" cy="180" r="18"/>
  <text class="label" x="170" y="180">6</text>

  <circle class="node" cx="230" cy="180" r="18"/>
  <text class="label" x="230" y="180">10</text>

  <circle class="node" cx="290" cy="180" r="18"/>
  <text class="label" x="290" y="180">14</text>

  <!-- Unbalanced tree (right) -->
  <!-- chain of right children -->
  <line class="edge" x1="660" y1="60" x2="720" y2="110"/>
  <line class="edge" x1="720" y1="110" x2="760" y2="170"/>
  <line class="edge" x1="760" y1="170" x2="780" y2="240"/>
  <line class="edge" x1="780" y1="240" x2="800" y2="310"/>

  <circle class="node" cx="660" cy="60" r="22"/>
  <text class="label" x="660" y="60">8</text>

  <circle class="node" cx="720" cy="110" r="20"/>
  <text class="label" x="720" y="110">9</text>

  <circle class="node" cx="760" cy="170" r="20"/>
  <text class="label" x="760" y="170">11</text>

  <circle class="node" cx="780" cy="240" r="18"/>
  <text class="label" x="780" y="240">13</text>

  <circle class="node" cx="800" cy="310" r="16"/>
  <text class="label" x="800" y="310">15</text>
</svg>


</div>

<div class="grid grid-cols-2">

<svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 900 520">
  <defs>
    <marker id="arrow-data" markerWidth="8" markerHeight="8" refX="7" refY="4" orient="auto">
      <path d="M0,0 L8,4 L0,8 z" fill="#e76f51" />
    </marker>
  </defs>

  <!-- Title -->
  <text x="450" y="30" class="title" text-anchor="middle">B-дерево порядка 4 (данные во всех узлах)</text>
  <text x="450" y="50" class="sub" text-anchor="middle">(каждый узел содержит ключи и связанные данные)</text>

  <!-- Root node -->
  <rect x="380" y="90" width="140" height="40" class="node" />
  <text x="450" y="110" class="node-text">20* | 40*</text>

  <!-- Edges from root -->
  <line x1="400" y1="130" x2="280" y2="190" class="edge"/>
  <line x1="450" y1="130" x2="450" y2="190" class="edge"/>
  <line x1="500" y1="130" x2="620" y2="190" class="edge"/>

  <!-- Level 2 -->
  <rect x="250" y="190" width="90" height="36" class="node"/>
  <text x="295" y="208" class="node-text">5* | 10*</text>

  <rect x="410" y="190" width="90" height="36" class="node"/>
  <text x="455" y="208" class="node-text">25* | 35*</text>

  <rect x="590" y="190" width="90" height="36" class="node"/>
  <text x="635" y="208" class="node-text">45* | 55*</text>

  <!-- Edges to leaves -->
  <line x1="295" y1="226" x2="260" y2="290" class="edge"/>
  <line x1="295" y1="226" x2="320" y2="290" class="edge"/>

  <line x1="455" y1="226" x2="420" y2="290" class="edge"/>
  <line x1="455" y1="226" x2="480" y2="290" class="edge"/>

  <line x1="635" y1="226" x2="600" y2="290" class="edge"/>
  <line x1="635" y1="226" x2="660" y2="290" class="edge"/>

  <!-- Leaf nodes -->
  <rect x="240" y="290" width="50" height="32" class="node"/>
  <text x="265" y="306" class="node-text">2*</text>

  <rect x="310" y="290" width="50" height="32" class="node"/>
  <text x="335" y="306" class="node-text">12*</text>

  <rect x="400" y="290" width="50" height="32" class="node"/>
  <text x="425" y="306" class="node-text">23*</text>

  <rect x="470" y="290" width="50" height="32" class="node"/>
  <text x="495" y="306" class="node-text">38*</text>

  <rect x="580" y="290" width="50" height="32" class="node"/>
  <text x="605" y="306" class="node-text">43*</text>

  <rect x="650" y="290" width="50" height="32" class="node"/>
  <text x="675" y="306" class="node-text">70*</text>

  <!-- Data records -->
  <rect x="120" y="400" width="100" height="24" class="record"/>
  <text x="130" y="412" class="record-text">record(id=2, ...)</text>

  <rect x="240" y="400" width="110" height="24" class="record"/>
  <text x="250" y="412" class="record-text">record(id=10, ...)</text>

  <rect x="380" y="400" width="120" height="24" class="record"/>
  <text x="390" y="412" class="record-text">record(id=25, ...)</text>

  <rect x="520" y="400" width="120" height="24" class="record"/>
  <text x="530" y="412" class="record-text">record(id=40, ...)</text>

  <rect x="680" y="400" width="120" height="24" class="record"/>
  <text x="690" y="412" class="record-text">record(id=55, ...)</text>

  <!-- Links -->
  <line x1="450" y1="130" x2="530" y2="400" class="data-edge"/>
  <line x1="295" y1="226" x2="250" y2="400" class="data-edge"/>
  <line x1="455" y1="226" x2="400" y2="400" class="data-edge"/>
  <line x1="635" y1="226" x2="690" y2="400" class="data-edge"/>

  <!-- Caption -->
  <text x="450" y="470" class="sub" text-anchor="middle">
    Каждый узел содержит ключ и связанные данные (*). Поиск может завершиться на любом уровне.
  </text>
</svg>

<svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 950 520">
  <defs>
    <marker id="arrow-data" markerWidth="8" markerHeight="8" refX="7" refY="4" orient="auto">
      <path d="M0,0 L8,4 L0,8 z" fill="#e76f51" />
    </marker>
    <marker id="arrow-leaf" markerWidth="8" markerHeight="8" refX="7" refY="4" orient="auto">
      <path d="M0,0 L8,4 L0,8 z" fill="#f4a261" />
    </marker>
  </defs>

  <!-- Title -->
  <text x="475" y="30" class="title" text-anchor="middle">Пример B⁺-дерева порядка 4</text>
  <text x="475" y="50" class="sub" text-anchor="middle">(данные хранятся только в листьях, листья связаны между собой)</text>

  <!-- Root -->
  <rect x="400" y="90" width="140" height="36" class="node"/>
  <text x="470" y="108" class="node-text">20 | 40</text>

  <!-- Edges -->
  <line x1="420" y1="126" x2="300" y2="190" class="edge"/>
  <line x1="470" y1="126" x2="470" y2="190" class="edge"/>
  <line x1="520" y1="126" x2="640" y2="190" class="edge"/>

  <!-- Level 2: internal nodes -->
  <rect x="260" y="190" width="80" height="34" class="node"/>
  <text x="300" y="207" class="node-text">10</text>

  <rect x="430" y="190" width="80" height="34" class="node"/>
  <text x="470" y="207" class="node-text">30 | 35</text>

  <rect x="610" y="190" width="80" height="34" class="node"/>
  <text x="650" y="207" class="node-text">50</text>

  <!-- Edges to leaves -->
  <line x1="300" y1="224" x2="260" y2="290" class="edge"/>
  <line x1="300" y1="224" x2="350" y2="290" class="edge"/>

  <line x1="470" y1="224" x2="440" y2="290" class="edge"/>
  <line x1="470" y1="224" x2="540" y2="290" class="edge"/>

  <line x1="650" y1="224" x2="620" y2="290" class="edge"/>
  <line x1="650" y1="224" x2="720" y2="290" class="edge"/>

  <!-- Leaves (data layer) -->
  <rect x="240" y="290" width="60" height="30" class="node"/>
  <text x="270" y="305" class="node-text">5* 10*</text>

  <rect x="330" y="290" width="60" height="30" class="node"/>
  <text x="360" y="305" class="node-text">15* 18*</text>

  <rect x="420" y="290" width="60" height="30" class="node"/>
  <text x="450" y="305" class="node-text">22* 25*</text>

  <rect x="510" y="290" width="60" height="30" class="node"/>
  <text x="540" y="305" class="node-text">30* 35*</text>

  <rect x="600" y="290" width="60" height="30" class="node"/>
  <text x="630" y="305" class="node-text">45* 50*</text>

  <rect x="690" y="290" width="60" height="30" class="node"/>
  <text x="720" y="305" class="node-text">60* 70*</text>

  <!-- Leaf links (horizontal chain) -->
  <line x1="300" y1="305" x2="330" y2="305" class="link"/>
  <line x1="390" y1="305" x2="420" y2="305" class="link"/>
  <line x1="480" y1="305" x2="510" y2="305" class="link"/>
  <line x1="570" y1="305" x2="600" y2="305" class="link"/>
  <line x1="660" y1="305" x2="690" y2="305" class="link"/>

  <!-- Data records -->
  <rect x="120" y="400" width="100" height="24" class="record"/>
  <text x="130" y="412" class="record-text">record(id=5, ...)</text>

  <rect x="250" y="400" width="100" height="24" class="record"/>
  <text x="260" y="412" class="record-text">record(id=15, ...)</text>

  <rect x="380" y="400" width="110" height="24" class="record"/>
  <text x="390" y="412" class="record-text">record(id=22, ...)</text>

  <rect x="520" y="400" width="110" height="24" class="record"/>
  <text x="530" y="412" class="record-text">record(id=35, ...)</text>

  <rect x="660" y="400" width="110" height="24" class="record"/>
  <text x="670" y="412" class="record-text">record(id=50, ...)</text>

  <rect x="800" y="400" width="110" height="24" class="record"/>
  <text x="810" y="412" class="record-text">record(id=70, ...)</text>

  <!-- Data pointers -->
  <line x1="270" y1="320" x2="180" y2="400" class="data-edge"/>
  <line x1="360" y1="320" x2="280" y2="400" class="data-edge"/>

  <line x1="450" y1="320" x2="420" y2="400" class="data-edge"/>
  <line x1="540" y1="320" x2="520" y2="400" class="data-edge"/>

  <line x1="630" y1="320" x2="690" y2="400" class="data-edge"/>
  <line x1="720" y1="320" x2="830" y2="400" class="data-edge"/>

  <!-- Caption -->
  <text x="475" y="470" class="sub" text-anchor="middle">
    Внутренние узлы содержат только ключи. Все данные — в листьях, которые связаны последовательной цепочкой.
  </text>
</svg>

</div>

> В большинстве БД используются B+ деревья из-за меньшего количества обращений к диску, быстрого последовательного доступа и большей эффективности для диапазонных запросов


---

<style scoped>
  li, p:not(h1 + p) {
    font-size: 12px;
    line-height: 1.1rem;
  }

  blockquote:not(ul blockquote) {
    margin-top: 4px;
  }
</style>

# Индексы

Советы по использованию

- **Не индексировать всё-всё-всё**. Каждый индекс - это дополнительная память. К тому же, индексы сильно замедляют операции записи в таблицу (`INSERT`, `UPDATE`, `DELETE`), так как помимо изменения таблицы необходимо перестраивать ассоциированные с ней структуры данных индексов
- **Индексировать столбцы, часто используемые в `WHERE`, `JOIN` и `ORDER BY`** - собственно, для этого они и нужны
- **Думать над составными (по нескольким столбцам) индексами** - если запросы часто работают с набором столбцов, то сильно может помочь составной индекс. В таким индексах огромную роль играет порядок столбцов, сначала должны идти столбцы с **наибольшей селекстивностью**
  > К слову, любые индексы в принципе теряют эффективность (более того, могут даже замедлять запросы) при понижении селективности
- **Индексировать внешние ключи** - если таблица с внешним ключом частом используется в `JOIN`, то чаще всего оправданно будет его индексировать
- **Анализировать и мониторить проивзодительность** - со временем эффективность индексов может падать из-за роста количества данных. Важно регулярно проверять на медленных запросах, насколько хорошо работают индексы. Многие СУБД предоставляют инструменты для анализа запросов: `EXPLAIN`, `EXPLAIN ANALYZE` и подобные. СУБД часто предоставляют механизмы для перестроения (Rebuild) или переорганизации индексов (Reorganize)
- **Тестировать производительность** - перед внедрением нового или изменением существующего индекса всегда необходимо предварительно тестировать влияние на производительность в тестовой среде, желательно как можно более приближенной к реальным нагрузкам

> **Селективность (Selectivity)** - мера уникальности значений, $Селективность=\frac{Кол-во уникальных значений}{Общее число строк}$

> **Кардинальность (Cardinality)** - общее количество уникальных значений. **Высокая кардинальность**, соответственно, - когда уникальных значений много

---
layout: cover
---

# Контейнеризация

---
class: table-dense
---

<style scoped>
  h3 {
    margin-top: 8px;
    font-weight: 700;
  }
</style>

# Контейнеризация

> **Контейнеризация** - технология, позволяющая упаковать приложение и все его зависимости в **изолированном**, **переносимом** и **работающем одинаково в любой среде** (на вашем компьютере, на устройтвах коллег, на сервере и т.д.) пространстве - **контейнере**

> **Не путать с виртуализацией!** Контейнеризация использует **одно ядро операционной системы** и изолирует приложения на уровне процессов, а **виртуализация** создаёт полноценные виртуальные машины с собственной операционной системой

### Преимущества

|||
| -------------------- | ---------------------------------------------------------------------------------- |
| **Портативность**    | Один и тот же контейнер работает в любой системе с Docker / Kubernetes            |
| **Изоляция**         | Каждый контейнер имеет своё окружение, не мешает другим                           |
| **Легковесность**         | Контейнеры используют общий ядро ОС — запускаются быстрее, чем виртуальные машины, а также занимают меньше места и потребляют меньше ресурсов |
| **Масштабируемость** | Легко разворачивать и дублировать контейнеры при росте нагрузки                   |
| **Управляемость**    | Удобно обновлять, деплоить и откатывать версии приложения                         |


---

<style scoped>
  h3 {
    margin: 8px 0;
    font-weight: 700;
  }

  li {
    font-size: 14px;
    line-height: 1.2rem;
  }
</style>

<h1>Docker <logos-docker-icon /></h1>

> **[Docker](https://www.docker.com)** - наиболее распространённая платформа для контейнеризации

### Основные компоненты

- **Образ (Image)** - это неизменяемый файл, который содержит все необходимое для запуска приложения: код, библиотеки, зависимости, инструменты и настройки. Является **шаблоном для создания контейнера**. Состоит из:
  - **Базовый образ** - минимальный шаблон, содержащий базовую операционную систему. Но можно создать и пустой образ без ОС
  - **Слои** - образы состоят из нескольких слоёв, каждый из которых меняет или добавляет что-то в предыдущем. Также они **кэшируются** для ускорения сборки
  - **Dockerfile** - файл с набором инструкций по сборке образа
- **Контейнер (Container)** - конкретный экземпляр **образа**, который был запущен и выполняется. Контейнеры изолируют приложение и его зависимости от остальной системы, обеспечивая консистентность и безопасность. Состоят, в свою очередь, из следующего:
  - **Образ**
  - **Изоляция** - специальные механизмы, обеспечивающие изоляцию процессов, файловой системы и ресурсов контейнера
  - **Файловая система** - контейнеры имеют свою собственную файловую систему, которая может быть изменена во время выполнения, но эти изменения не влияют на исходный образ
- **Реестр (Registry)** - централизованное хранилище, позволяющее хранить, управлять и распространять образы. Бывают публичными и частными. Основной публичный реестр для Docker - [Docker Hub](https://hub.docker.com/)
---

<style scoped>
  div {
    --slidev-code-font-size: 11px;
    --slidev-code-line-height: 13px;
  }
</style>

# Docker

Dockerfile

> **Dockerfile** - файл с описанием инструкций того, как должен быть собран Docker-образ

```dockerfile
# Указание базового образа
FROM python:3.12-slim

# Указание рабочей директории, в которых исполнятся все следующие команды
WORKDIR /app

# Копирование текущей директории в WORKDIR
COPY . .

# Установка переменной окружения
ENV SERVER_PORT=3000

# Выполнение команды внутри образа
RUN pip install -r requirements.txt

# Документация о том, что приложение внутри контейнера работает на порту 3000
# Не открывает порт для доступа вне контейнера!
EXPOSE 3000

# Определение команду, которая выполнится при запуске контейнера
CMD ["python", "app.py"]
```

---

<style scoped>
  h3 {
    font-size: 20px;
    font-weight: 700;
    margin: 12px 0;
    line-height: 1.4rem;
  }
</style>

# Docker

Основы работы

> Перед работой с Docker обязательно нужнно запустить **Docker Engine**, который включает в себя специальный демон (daemon) - специальный фоновый процесс, который управляет работой Docker (все команды CLI обращаются к ней). Примеры движков:
> - **Docker Desktop** - по совместительству включает и CLI, и GUI
> - **Colima** - легковесная альтернатива для macOS/Linux, предлагающая только CLI
> - **Podman desktop** - мультиплатформенное GUI, работает без daemon

### Базовые команды

```sh
docker build -t <image-tag> . # Сборка образа, Dockerfile ищется в `.`, `-t` - человекочитаемое название образа
docker run -dp <host_port>:<container_port> <image-tag> # Запуск контейнера, `-d` - detached mode (запуск в фоне), `-p` - проброс (маппинг) портов хоста и контейнера
docker ps # Просмотр информации о запущенных контейнерах, с `-a` - и об остановленных
docker logs <container_log> # Просмотр логов контейнера
docker stop <container-id> # Остановка контейнера
docker rm <container-id> # Удаление контейнера
docker exec <container_id> -it bash # Запуск команды внутри контейнера, в данном случае - bash, `-it` - интерактивный режим
docker start <container_id> # Запуск остановленного контейнера
```

---

<style scoped>
  li, p:not(h1 + p) {
    font-size: 12px;
    line-height: 1.1rem;
  }

  h3 {
    font-size: 20px;
    font-weight: 700;
    margin: 12px 0;
    line-height: 1.4rem;
  }
</style>

# Docker

Тома (Volumes) и связывание директорий (Bind Mounts)

> **Том (Volume)** - специальное место хранения данных контейнера на устройстве-хосте, которое сохраняется независимо от жизненного цикла контейнера

### Для чего нужны
- **Персистентность** - сохранения данных после удаления контейнера
- Одни и те же данные можно использовать в разных контейнерах

### Команды

```sh
docker volume create <name> # Создание тома
docker volume ls # Просмотр всех томов
docker volume rm <name> # Удаление тома
docker run -v <volume_name>:<container_path> # Монтирование (подключение) тома к контейнеру
docker volume inspect <name> # Просмотр информации о 
```

Так же можно связать конкретную директорию хоста с директорией контейнера (Bind Mounts):
```sh
docker run -v <host_path>:<container_path> # Монтирование (подключение) тома к контейнеру, например `-v "$(pwd):/app"`
```

> В таком случае контейнер будет использовать файлы и папки из **реальной файловой системы** хоста. Это может быть полезно для разработки, чтобы сразу видеть изменения в контейнере, но тогда контейнер становится **менее переносимым**


---

<style scoped>
  h3 {
    font-size: 20px;
    font-weight: 700;
    margin: 6px 0;
    line-height: 1.4rem;
  }

  div {
    --slidev-code-font-size: 9px;
    --slidev-code-line-height: 11px;
  }
</style>

# Docker

Сети (Networks)

> **Сеть (Network)** - это виртуальная сеть, которая позволяет контейнерам взаимодействовать друг с другом и с внешним миром. По умолчанию **контейнеры полностью изолированы**

<div class="grid grid-cols-2 gap-2">

<div>

### Основные команды

```sh
docker network create <name> # Создание сети
docker network ls # Просмотр всех сетей
docker network rm <name> # Удаление сети
docker network inspect <name> # Просмотр подробной информации о сети
```

</div>
<div>

### Пример

```sh
docker network create <network_name>

# Запуск контейнера и подключение к сети
docker run -d \
  --network <network-name> \
  # Это будет именем хоста, по которому будут посылаться запросы (вместо ip)
  --network-alias mysql \
  -v <volume-name>:<mounted-path> \
  -e MYSQL_ROOT_PASSWORD=secret \
  -e MYSQL_DATABASE=todos \
  mysql:5.7

# Запуск контейнера и подключение к сети
docker run -dp 80:80 \
  -w /app -v "$(pwd):/app" \
  --network <network-name> \
  -e MYSQL_HOST=<network_alias> \
  -e MYSQL_USER=root \
  -e MYSQL_PASSWORD=secret \
  -e MYSQL_DB=todos \
  node:12-alpine \
  sh -c "yarn install && yarn run dev"
```

</div>

</div>

---

<style scoped>
  h3 {
    font-size: 20px;
    font-weight: 700;
    margin: 8px 0;
    line-height: 1.4rem;
  }
</style>

# Docker

Полезности

- `docker scan <image-name>` - проверка образа на уязвимости
- `docker image history --no-trunc <image-name>` - просмотр команд, которые запускались на каждом слое
- **Кэширование** - docker проверяет, совпадают ли предыдущие слои и команды, если да, то слой берётся из кэша, если нет, то он и все последующие слои пересобираются заново

<div class="grid grid-cols-2 gap-2">

<div>

### Плохой Dockerfile

```dockerfile
FROM python:3.12

COPY . .
# Этот слой будет пересобран, если изменились любые файлы
RUN pip install -r requirements.txt

CMD ["python", "server.py"]
```

</div>
<div>

### Хороший Dockerfile

```dockerfile
FROM python:3.12

COPY requirements.txt .
# Если файл requirements.txt не изменился,
# то этот слой кэшируется
RUN pip install -r requirements.txt

COPY . .

CMD ["python", "server.py"]
```


</div>

</div>

---

<style scoped>
  div {
    --slidev-code-font-size: 10px;
    --slidev-code-line-height: 12px;
  }
</style>

# Docker-compose

> Docker Compose — это инструмент для описания и запуска нескольких контейнеров как единого приложения. Конфигурация описывается в файле `docker-compose.yml`

<div class="grid grid-cols-2 gap-2">

<div>

```sh
docker-compose up # Запуск всех сервисов
docker-compose stop # Остановка всех контейнеров
docker-compose down # Остановка и удаление всех контейнеров
docker-compose ps # Информация о запущенных сервисах
docker-compose logs # Логи всех сервисов
```

> `docker-compose up` автоматически создаёт сеть (`<имя_проекта>_default`) и подключает все контейнеры к ней по умолчанию

</div>

```yaml
version: "3.9"

services:
  app:
    build: . # Собирает образ из Dockerfile в текущей папке
    container_name: backend
    ports:
      - 3000:3000 # Проброс портов
    environment:
      - DATABASE_URL=postgresql://postgres:example@db:5432/mydb
    depends_on:
      - db # Запустится только после сервиса db

  db:
    image: postgres:15
    container_name: postgres-db
    environment:
      POSTGRES_USER: postgres
      POSTGRES_PASSWORD: example
      POSTGRES_DB: mydb
    volumes:
      - pgdata:/var/lib/postgresql/data # Персистентность данных

volumes: # Объявление томов
  pgdata:
```

</div>

---

<style scoped>
  h3 {
    font-size: 20px;
    font-weight: 700;
    margin: 12px 0;
    line-height: 1.4rem;
  }
</style>

# ORM

> **ORM (Object-Relational Mapping)** — это технология программирования, позволяющая работать с базой данных при помощи **объектов языка программирования**, а не через SQL-запросы напрямую

### Преимущества

- Повышает читаемость и удобство
- Практически полностью избавляет от необходимости писать SQL (в особых случаях это всё ещё может требоваться для оптимизации)
- Инкапсулирует (скрывает) от разработчика взаимодействие с СУБД, то есть позволяет не думать о том, какая именно СУБД используется. Вдобавок её в любой момент можно поменять на другую без необходимости переписывания запросов
- Обеспечивает безопаность (защищает от SQL-инъекций)
- Упрощает построение связей между таблицами
- Поддерживает инструменты для миграции

---
src: ./_shared.md#1
---

---

# Дополнительные материалы

### SQL

- [Яндекс Практикум - Индексы в SQL: зачем они нужны и как их использовать](https://practicum.yandex.ru/blog/indeksy-v-sql-kak-rabotayut-zachem-nuzhny/)
- [planetscale - B-trees and database indexes](https://planetscale.com/blog/btrees-and-database-indexes) - статья про B и B+ деревья с визуализацией и примерами

### Docker

- [Docker 101](https://www.docker.com/101-tutorial/) - интерактивный туториал (на английском)
- [Habr - Docker Compose для начинающих](https://habr.com/ru/companies/ruvds/articles/450312/)