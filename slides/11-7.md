---
theme: default
title: "SQL: DDL, Constraints, DML, DQL / Курс по веб-разработке, 11 класс"
class: text-center
drawings:
  persist: false
transition: slide-left
mdc: true
fonts:
  sans: Montserrat
hideInToc: true
browserExporter: true
---

# Курс по веб-разработке

<h2 class="color-gray-400 fw-200">SQL: DDL, Constraints, DML, DQL</h2>

---
layout: cover
---

# SQL

Рассматриваемая БД (**для СУБД SQLite)** находится в `snippets/db/sql/chinook.db`, большинство примеров запросов написаны для неё

---

<style scoped>
  li {
    margin-bottom: 4px;
    font-size: 14px;
    line-height: 1.2rem;
  }

  ul {
    margin-top: 8px;
  }

  div {
    --slidev-code-font-size: 9px;
    --slidev-code-line-height: 12px;
  }
</style>

# DDL

Constraints

> **Constraints** — это ограничения, необходимые для обеспечения целостности и корректности данных, которые определяются при создании или изменении таблицы

- `PRIMARY KEY`- гарантирует уникальность идентификатора для каждой записи
- `FOREIGN KEY`- обеспечивает ссылочную целостность данных между таблицами. Под целостностью тут подразумевается, что мы не сможем удалить запись из таблицы, если на неё есть ссылка из другой таблицы
- `UNIQUE`- делает все значения уникальными
- `NOT NULL` - исключает хранение пустого значения (`NULL`)
- `CHECK`- позволяет проверять значений на выполнение какому-то набору критериев
- `DEFAULT`- устанавливает значение по умолчанию

<div class="grid grid-cols-2 gap-2">

```sql
-- Создание таблицы с ограничениями
CREATE TABLE students (
  student_id INT PRIMARY KEY,                          -- Уникальный идентификатор (PRIMARY KEY)
  full_name VARCHAR(50) NOT NULL,                     -- Обязательно к заполнению (NOT NULL)
  email VARCHAR(100) UNIQUE,                           -- Уникальное значение (UNIQUE)
  birth_date DATE CHECK (birth_date <= CURRENT_DATE),  -- Проверка корректности (CHECK)
  gender CHAR(1) CHECK (gender IN ('M', 'F')),         -- Допустимые значения (CHECK)
  enrollment_date DATE DEFAULT CURRENT_DATE,           -- Значение по умолчанию (DEFAULT)
  course_id INT,                                       -- Внешний ключ (FOREIGN KEY)
  FOREIGN KEY (course_id) REFERENCES courses(course_id) -- Связь с таблицей courses
);
```

```sql
-- Добавление ограничений в существующую таблицу
ALTER TABLE students
ADD CONSTRAINT uq_students_email UNIQUE (email);

ALTER TABLE students
ADD CONSTRAINT chk_birthdate CHECK (birth_date <= CURRENT_DATE);

ALTER TABLE students
ADD CONSTRAINT fk_students_course
FOREIGN KEY (course_id)
REFERENCES courses(course_id);
```

</div>

---
transition: none
class: table-dense
---

<style scoped>
  p:not(h1 + p) {
    font-size: 14px;
    line-height: 1.2rem;
  }

  td {
    font-size: 14px;
  }
</style>

# DDL

Constraints. Целостность внешних ключей

> Внешние ключи **гарантируют целостность**. Это значит, на какую-то запись при помощи ключа ссылается другая (или несколько других), то по умолчанию её нельзя будет удалить или изменить первичный ключ. Необходимо либо **вручную разрешить все проблемные ссылки**, либо **задать поведение при удалении/изменении по умолчанию**.

Поведение по умолчанию задаётся при помощи специальных конструкций при создании внешнего ключа: `ON DELETE` и `ON UPDATE`

| Опция (стратегия)            | Что делает                                      |
| ----------------- | ----------------------------------------------------------------------- |
| **`CASCADE`**     | Автоматически удаляет или обновляет связанные записи в дочерней таблице |
| **`SET NULL`**    | Устанавливает значение внешнего ключа в `NULL`                          |
| **`SET DEFAULT`** | Устанавливает значение внешнего ключа по умолчанию                      |
| **`RESTRICT`**    | Запрещает удаление/изменение, если есть связанные записи                |
| **`NO ACTION`**   | Поведение по умолчанию (аналогично RESTRICT в большинстве СУБД)         |

---

# DDL

Constraints. Целостность внешних ключей

```sql
CREATE TABLE departments (
    id INT PRIMARY KEY,
    name VARCHAR(50)
);

CREATE TABLE employees (
    id INT PRIMARY KEY,
    name VARCHAR(100),
    department_id INT,
    FOREIGN KEY (department_id)
        REFERENCES departments(id)
        -- При обновлении первичного ключа записи из таблицы departments
        -- автоматически обновятся и соответствующие им внешние ключи в employees
        ON UPDATE CASCADE
        -- При удалении записи из таблицы departments для всех связанных записий
        -- из employees внешний ключ станет пустым (NULL)
        ON DELETE SET NULL
);
```

---

# DML

Data Manipulation Language

<div class="grid grid-cols-2 gap-2">

<div>

- `INSERT` - вставка строк
  ```sql
  INSERT INTO
  artists (name)
  VALUES
    ('Принц и Комик'),
    ('Oasis');
  ```
- `UPDATE` - обновление строк
  ```sql
  UPDATE artists
  SET
    name = 'Король и Шут'
  WHERE
    name = 'Принц и Комик';
  ```
- `DELETE` - удаление строк
  ```sql
  DELETE FROM artists
  WHERE
    name LIKE '%black%'
  ```

</div>

<div>

- `MERGE` - объединение таблиц
  ```sql
  MERGE INTO employees AS target
  USING new_employees AS source
  -- Условие для объединения строк
  ON target.id = source.id

  -- Если запись уже существует, то обновляем данные
  WHEN MATCHED THEN
      UPDATE SET
          target.name = source.name,
          target.position = source.position,
          target.salary = source.salary

  -- Если записи нет, то создаём новую
  WHEN NOT MATCHED THEN
      INSERT (id, name, position, salary)
      VALUES (source.id, source.name, source.position, source.salary)

  -- (опционально) Если запись в основной таблице
  -- отсутствует в новых данных, то удаляем
  WHEN NOT MATCHED BY SOURCE THEN DELETE;
  ```

</div>

</div>

---

<style scoped>
  li {
    font-size: 14px;
    line-height: 1.5rem;
  }

  ul {
    margin-top: 8px;
  }

  div {
    --slidev-code-font-size: 13px;
    --slidev-code-line-height: 14px;
  }
</style>

# DQL

Data Query Language

Основным оператором является `SELECT`. Общий вид запроса:

```
SELECT <столбец_1>, ..., <столбец_n>       - Выбор результирующих столбцов
FROM <таблица>                             - Источник записей
[JOIN <таблица> ON <условие>]              - Присоединение другой таблицы
[WHERE <условие_1> AND/OR <условие_2>]     - Фильтрация результирующих записей
[GROUP BY <столбец_1>, ..., <столбец_n>]   - Группировка по столбцам
[HAVING <условие_1>, ..., <условие_n>]     - Фильтрация групп
[ORDER BY столбец [ASC|DESC]]              - Сортировка результирующих записей
[LIMIT <n>]                                - Ограничение количества результирующих строк
[OFFSET <n>];                              - Отступ, то есть пропуск <n> первых записей
```

- Чтобы выбрать только уникальные значения или комбинации, можно использовать `SELECT DISTINCT`
- Результирующие столбцы можно переименовывать при помощи `AS`, например `SELECT name AS artist_name FROM artists`
- Таблице в запросе можно задать псевдоним, например:
  ```sql
  SELECT * FROM artists a
  JOIN tracks t ON ...
  ```
  тогда к столбцам можно будет обращаться как `<псевдоним>.<столбец>`

---

# DQL

<style scoped>
  li {
    margin-bottom: 4px;
    font-size: 14px;
    line-height: 1.3rem;
  }

  h3 {
    font-size: 20px;
    margin-bottom: 4px;
    font-weight: 700;
  }

  div {
    --slidev-code-font-size: 11px;
    --slidev-code-line-height: 12px;
  }
</style>

Фильтрация

> `WHERE` позволяет выбрать только записи, подходящие под определённые условия

<div class="grid grid-cols-2 gap-2">

<div>

### Доступные операторы (основные)
- `=` - строгое равенство
- `<>` - не равно
- `<` - меньше
- `>` - больше
- `BETWEEN <n1> AND <n2>` - находится в диапазоне
- `IS NULL` - является ли пустым
- `IN (...)` - входит во множество, например `IN (1, 2, 3)`
- `LIKE` - подходит ли под шаблон строки, например `LIKE '%benz _-class'`
  - `%` - любая подстрока любой длины (от 0 до ∞)
  - `_` - любой одиночный символ
- `GLOB` - соответствие регулярному выражению (для SQLite, в других СУБД может быть другой оператор)

</div>


<div>

### Примеры запросов

```sql
-- Выбираем первые 10 треков, которые длятся больше 500 секунд
SELECT * FROM tracks t
WHERE t.Milliseconds > POW(10, 5) * 5
LIMIT 10;

-- Выбираем треки с композиторами из множества
-- максимум 50 треков с отступом 5
SELECT name, AlbumId, UnitPrice FROM tracks
WHERE 
  Composer IN ('AC/DC', 'Queen')
LIMIT 50
OFFSET 5;

-- Выбираем всех артистов, содержащих слово 'black' в названии
SELECT name AS artist_name
FROM artists
WHERE
  name LIKE '%black%'
```

</div>

</div>

---

# DQL

Сортировка

> `ORDER BY` позволяет отсортировать результаты по одному или нескольким столбцам в заданном порядке

> Порядок указания столбцов имеет значение. Если значение первого столбца одинаково, то сравниваться будет второй и так далее

```sql
-- Выбираем 10 самых длительных треков
SELECT * 
FROM tracks
ORDER BY Milliseconds DESC
LIMIT 10;

-- Сортируем трки по длительности (в минутах) и названию
SELECT 
  name, 
  ROUND(t.Milliseconds / 1000 / 60) as duration 
FROM tracks t
WHERE duration BETWEEN 10 AND 20
ORDER BY duration DESC, t.name ASC
LIMIT 50;
```

---
transition: slide-up
---

# DQL

`JOIN`

> `JOIN` используется для **объединения данных** из двух и более таблиц на основе связанного столбца (обычно внешнего ключа)

---

<style scoped>
  .slidev-layout {
    padding: 0;
  }

  .grid-cols-3 {
    & > div {
      padding: 8px;
    }

    h2 {
      font-size: 18px;
      margin-bottom: 4px;
    }

    p {
      font-size: 12px;
      line-height: 1.1rem;
      margin: 4px 0;
    }
  }

  li {
    font-size: 14px;
    line-height: 1.2rem;
  }

  div {
    --slidev-code-font-size: 9px;
    --slidev-code-line-height: 12px;
  }
</style>

<div class="grid grid-cols-3 gap-2">
    
<!-- INNER JOIN -->
<div class="bg-gray-200 dark:bg-gray-800 p-5 border-rd-4 shadow">
  <h2 class="text-xl font-semibold mb-2">INNER JOIN</h2>
  <p class="text-gray-500 dark:text-gray-200 mb-3">Возвращает только строки, у которых есть совпадение в обеих таблицах</p>
  <div class="mb-3">
    <!-- Простейшая визуализация множеств -->
    <div class="flex justify-center items-center mb-1">
      <div class="w-16 h-16 bg-blue-400 rounded-full opacity-50 -mr-8"></div>
      <div class="w-16 h-16 bg-green-400 rounded-full opacity-50"></div>
    </div>
    <p class="text-sm text-center text-gray-500 dark:text-gray-200">Пересечение множеств</p>
  </div>
  
```sql
SELECT emp1.FirstName, emp2.FirstName
FROM employees emp1
INNER JOIN employees emp2 
ON emp1.EmployeeId = emp2.ReportsTo;
```

</div>

<!-- LEFT JOIN -->
<div class="bg-gray-200 dark:bg-gray-800 p-5 border-rd-4 shadow">
  <h2 class="text-xl font-semibold mb-2">LEFT JOIN</h2>
  <p class="text-gray-500 dark:text-gray-200 mb-3">Возвращает все строки из левой таблицы и совпадающие из правой</p>
  <div class="mb-3">
    <div class="flex justify-center items-center mb-1">
      <div class="w-16 h-16 bg-blue-400 rounded-full z-1"></div>
      <div class="w-16 h-16 bg-green-400 rounded-full opacity-50 -ml-8"></div>
    </div>
    <p class="text-sm text-center text-gray-500 dark:text-gray-200">Левое множество полностью</p>
  </div>
  
```sql
SELECT emp1.FirstName, emp2.FirstName
FROM employees emp1
LEFT JOIN employees emp2 
ON emp1.EmployeeId = emp2.ReportsTo;
```

</div>

<!-- RIGHT JOIN -->
<div class="bg-gray-200 dark:bg-gray-800 p-5 border-rd-4 shadow">
  <h2 class="text-xl font-semibold mb-2">RIGHT JOIN</h2>
  <p class="text-gray-500 dark:text-gray-200 mb-3">Возвращает все строки из правой таблицы и совпадающие из левой</p>
  <div class="mb-3">
    <div class="flex justify-center items-center mb-1">
      <div class="w-16 h-16 bg-blue-400 rounded-full opacity-50 -mr-8"></div>
      <div class="w-16 h-16 bg-green-400 rounded-full z-1"></div>
    </div>
    <p class="text-sm text-center text-gray-500 dark:text-gray-200">Правое множество полностью</p>
  </div>
  
```sql
SELECT emp1.FirstName, emp2.FirstName
FROM employees emp1
RIGHT JOIN employees emp2 
ON emp1.EmployeeId = emp2.ReportsTo;
```

</div>

<!-- FULL OUTER JOIN -->
<div class="bg-gray-200 dark:bg-gray-800 p-5 border-rd-4 shadow">
  <h2 class="text-xl font-semibold mb-2">FULL OUTER JOIN</h2>
  <p class="text-gray-500 dark:text-gray-200 mb-3">Возвращает все строки из обеих таблиц, совпадения объединяет, несовпадения — с NULL</p>
  <div class="mb-3">
    <div class="flex justify-center items-center mb-1">
      <div class="w-16 h-16 bg-blue-400 rounded-full opacity-50 -mr-8"></div>
      <div class="w-16 h-16 bg-green-400 rounded-full opacity-50 -ml-8"></div>
    </div>
    <p class="text-sm text-center text-gray-500 dark:text-gray-200">Объединение множеств</p>
  </div>
  
```sql
SELECT emp1.FirstName, emp2.FirstName
FROM employees emp1
FULL OUTER JOIN employees emp2
ON emp1.EmployeeId = emp2.ReportsTo;
```

</div>

<!-- CROSS JOIN -->
<div class="bg-gray-200 dark:bg-gray-800 p-5 border-rd-4 shadow">
  <h2 class="text-xl font-semibold mb-2">CROSS JOIN</h2>
  <p class="text-gray-500 dark:text-gray-200 mb-3">Создает <b>декартово произведение</b> двух таблиц</p>
  <div class="mb-3">
    <div class="relative grid grid-cols-2 gap-1 justify-items-center">
      <div class="w-12 h-12 bg-blue-400 rounded-full"></div>
      <div class="w-12 h-12 bg-green-400 rounded-full"></div>
      <div class="w-12 h-12 bg-blue-400 rounded-full"></div>
      <div class="w-12 h-12 bg-green-400 rounded-full"></div>
      <div style="position: absolute; width: 31%; height: 1px; left: 35%; top: 20%;" class="bg-gray-500"></div>
      <div style="position: absolute; width: 36%; height: 1px; left: 35%; top: 20%; transform-origin: top left; transform: rotate(30deg)" class="bg-gray-500"></div>
      <div style="position: absolute; width: 31%; height: 1px; left: 35%; top: 75%;" class="bg-gray-500"></div>
      <div style="position: absolute; width: 36%; height: 1px; left: 35%; top: 75%; transform-origin: top left; transform: rotate(-30deg)" class="bg-gray-500"></div>
    </div>
    <p class="text-sm text-center text-gray-500 dark:text-gray-200">Все комбинации</p>
  </div>
  
```sql
SELECT e.name, d.name AS department
FROM employees e
CROSS JOIN departments d;
```
</div>

<div class="bg-gray-200 dark:bg-gray-800 p-5 border-rd-4 shadow">
  <h2 class="text-xl font-semibold mb-2">И ещё...</h2>

- По умолчанию (если писать просто `JOIN`) используется `INNER JOIN`
- `ANTI LEFT JOIN` - возвращает все строки из левой таблицы, для которых нет совпадений в правой
- `ANTI RIGHT JOIN` - возвращает все строки из правой таблицы, для которых нет совпадений в левой
- `ANTI OUTER JOIN` - возвращает все строки, за исключением пересечений

</div>

</div>

---
transition: none
---

<style scoped>
  h3 {
    font-weight: 700;
    margin: 8px 0;
  }
</style>

# DQL

`GROUP BY` и агрегация

> `GROUP BY` используется для объединения строк с одинаковыми значенями какого-то атрибута и применения к каждой группе агрегирующей функции

<br />

> **Агрегация** - процесс, при котором множество значений сводятся к единственному

### Примеры агрегирующих функций

- `COUNT()` - количество значений
- `SUM()` - сумма
- `AVG()` - среднее значение
- `MIN()` - минимальное значение
- `MAX()` - максимальное значение

---

# DQL

`GROUP BY` и агрегация

```sql
SELECT
  a.Name,
  COUNT(*) as tracks_count,
  ROUND(AVG(t.Milliseconds / 1000 / 60), 2) as average_duration
FROM artists a
  JOIN albums al ON al.ArtistId = a.ArtistId
  JOIN tracks t ON t.AlbumId = al.AlbumId
GROUP BY
  a.Name
HAVING average_duration < 10 AND tracks_count > 5
ORDER BY average_duration DESC, tracks_count DESC;
```

- **Все столбцы, значения которых есть в `SELECT` и они не агрегируются, должны быть указаны в `GROUP BY`**
- Группировка может производиться по нескольким столбцам
- `HAVING` используется для фильтрации групп по какому-то условию
- В результате `GROUP BY` будет ровно столько строк, сколько уникальных значений в группируемом столбце

---

<style scoped>
  li {
    margin-bottom: 4px;
    font-size: 14px;
    line-height: 1.3rem;
  }

  ul {
    margin-top: 8px;
  }

  h3 {
    font-size: 18px;
    font-weight: 700;
    margin: 8px 0 0;
    line-height: 1.4rem;
  }

  div {
    --slidev-code-font-size: 11px;
    --slidev-code-line-height: 12px;
  }
</style>

# DQL

Подзапросы (Subqueries)

> **Подзапрос (Вложенный запрос, subquery)** — это запрос внутри другого SQL-запроса.
Используются, когда нужно сначала получить промежуточные данные, а потом использовать их в основном запросе

### Типы подзапросов

<div class="grid grid-cols-2 gap-2">

<div>

- **Скалярный** - возвращающий одно значение. Используется в `SELECT`, `WHERE` и `HAVING`
  ```sql
  SELECT Name, UnitPrice
  FROM tracks
  WHERE UnitPrice > (
    SELECT AVG(UnitPrice) FROM tracks
  );
  ```
- **Множественный** - возвращающий набор значений. Используется в `IN`, `ANY` и `ALL`
  ```sql
  SELECT EmployeeId, FirstName, LastName 
  FROM employees
  WHERE EmployeeId NOT IN (
    SELECT DISTINCT SupportRepId 
    FROM customers
    WHERE SupportRepId IS NOT NULL
  );
  ```

</div>

- **Табличный** - возвращает временную таблицу. Используется в `FROM`
  ```sql
  SELECT 
    sub.CustomerId,
    c.FirstName,
    c.LastName,
    ROUND(sub.AvgInvoiceTotal, 2) as avg_total
  FROM (
      SELECT 
          CustomerId,
          AVG(Total) AS AvgInvoiceTotal
      FROM invoices
      GROUP BY CustomerId
  ) AS sub
  JOIN customers c ON c.CustomerId = sub.CustomerId
  ORDER BY sub.AvgInvoiceTotal DESC
  LIMIT 5;
  ```

</div>

---

# DQL

Порядок выполнения запроса

1. `FROM` и `JOIN`'ы - определяются исходные строки, с которыми будетр работать запрос
2. `WHERE` - исключаются строки, не подходядящие под условия
3. `GROUP BY` - отфильтрованные строки группируются по указанным столбцам
4. `HAVING` - исключаются группы, не подходядящие под условия
5. `SELECT` - вычисляются все выражения для расчёта значений
6. `DISTINCT` - исключаются строки с дублирующимися значениями в помеченных столбцах
7. `ORDER BY` - строки сортируются
8. `LIMIT` и `OFFSET` - выбираются строки с учётом предела количества и отступа

---
layout: cover
---

# Практика

https://sqlbolt.com/

---
src: ./_shared.md#1
---

---

# Дополнительные материалы

- [SQL Academy - Ограничения столбцов (Constraints) в SQL](https://sql-academy.org/ru/guide/constraints)
- [SQL Academy - Группировка, оператор GROUP BY](https://sql-academy.org/ru/guide/groupping)
- [SQL Academy - Подзапросы](https://sql-academy.org/ru/guide/nested-sql-queries)
- [Яндекс Практикум - Как работает SQL JOIN: основные типы и примеры](https://practicum.yandex.ru/blog/chto-takoe-sql-join/)