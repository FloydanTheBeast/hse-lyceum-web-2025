---
theme: default
title: "Авторизация / Курс по веб-разработке, 11 класс"
class: text-center
drawings:
  persist: false
transition: slide-left
mdc: true
fonts:
  sans: Montserrat
hideInToc: true
browserExporter: true
---

# Курс по веб-разработке

<h2 class="color-gray-400 fw-200">Тестирование</h2>

---

<style scoped>
  h3 {
    font-weight: 700;
    font-size: 18px;
  }

  p:not(h1 + p), li {
    font-size: 16px;
    line-height: 1.6rem;
  }

  blockquote {
    margin-top: 12px;
  }
</style>

# Тестирование

<div></div>

**Тестирование программного обеспечения** — это процесс проверки того, что продукт работает корректно, соответствует требованиям и ведёт себя предсказуемо во всех предусмотренных сценариях

### Зачем нужно тестирование?

- **Обеспечение качества** - помогает убедиться, что продукт надёжен, удобен и функционален
- **Предотвращение дефектов** - выявляет ошибки до того, как ими столкнутся пользователи
- **Снижение рисков** - уменьшает вероятность серьёзных отказов в продакшене
- **Экономия ресурсов** - исправлять найденный заранее дефект дешевле, чем после релиза
- **Подтверждение соответствия требованиям** - проверяет, что продукт делает именно то, что должен.
- **Утойчивость к изменениям** - позволяет быть уверенным, что новые изменения в системе не приведут к поломке старых частей

> **Тестирование** — <mark>важнейшая часть процесса разработки</mark>, позволяющая создавать стабильные и качественные системы

---

# Тестирование

Разделение по уровню

> Какую часть системы тестируем?

<br />

- **Статическое тестирование** - метод проверки программного обеспечения, который не требует выполнения кода. Включает анализ кода (при помощи статических анализаторов), документации и других артефактов разработки для выявления потенциальных проблем
- **Unit-тестирование** — проверка отдельных модулей или функций
- **Интеграционное** — проверка взаимодействия модулей между собой
- **Системное** — оценка работы всей системы целиком
- **Приёмочное (User Acceptance Testing, UAT)** — проверка продукта с точки зрения бизнеса и пользователя на соответствие требованиям

---

# Тестирование

По аспекту

> Какую характеристику проверяем?

<br />

- **Функциональные** - проверка функциональных требований, т.е. логики работы системы
- **Нефункциональные** - проверка нефункциональных требований к системе, например:
  - Производительности
  - Безопасность
  - Удобство пользования (Usability)
  - Совместимость
  - и другие

---

# Тестирование

По способу выполнения

> Каким образом тестируем?

<br />

- **Ручное тестирование** — проверки выполняет человек
- **Автоматизированное** — проверки выполняет код, написанный тестировщиком или разработчиком

---

# Тестирование

Другие виды тестов

- **Смоук тесты (smoke tests)** - базовые тесты для быстрой проверки основной функциональности
- **Регрессионные (regression) тесты** - проверка, чтобы новые изменения не сломали существующую функциональность
- **Исследовательские (exploratory) тесты** - неструктурированные тесты, где тестировщик активно ищет ошибки, опираясь на свой опыт и интуицию. По сути, свободное изучение продукта, чтобы найти неожиданные проблемы
- **Санитарные тесты** - поверхностные тесты, которые обычно проводятся после получения новой версии программы для быстрой оценки её качества

---

<style scoped>
  h3 {
    font-weight: 700;
    font-size: 18px;
  }

  p:not(h1 + p), li {
    font-size: 16px;
    line-height: 1.4rem;
  }
</style>

# Тестирование

Пирамида

**Пирамида тестирования** — это модель, описывающая оптимальное распределение автоматизированных тестов по уровням. Она помогает выстроить эффективную стратегию тестирования, где основная нагрузка приходится на быстрые и дешёвые в поддержке тесты

<img src="https://habrastorage.org/r/w780/getpro/habr/upload_files/e18/11b/5f0/e1811b5f08387f0ab46959618817af5b.png" class="dark:filter-invert-[1] w-80 mx-auto" />

### Зачем нужна?

- **Снижает стоимость тестирования** - упор на дешёвые юнит-тесты
- **Делает систему тестов устойчивой и надёжной**
- **Ускоряет релизы** - большинство тестов выполняется очень быстро
- **Обеспечивает уверенность в качестве** на всех уровнях - от функции до всей системы

---
layout: two-cols
---

<div>
  <img src="/test-pyramid.png" class="dark:filter-invert-[1]"></img>
  <figcaption>Чем меньше площадь фигуры, тем ближе тесты к тому, с чем взаимодействует реальный пользователь, но выше затраты на написание и меньше количество</figcaption>
</div>

::right::

<div class="mt-38">
  <img src="https://testomat.io/wp-content/uploads/2025/04/Alternatives_to_Testing_pyramid.png" class="dark:filter-invert-[1]"></img>
  <figcaption>Помимо пирамиды существуют и другие, более редкие модели</figcaption>
</div>

---

<style scoped>
  h3 {
    font-weight: 700;
    font-size: 18px;
  }

  h4 {
    font-weight: 700;
    font-size: 15px;
  }

  p:not(h1 + p), li, blockquote {
    font-size: 12px;
    line-height: 1.1rem;
  }

  blockquote {
    margin-top: 12px;
  }
</style>

# Тестирование: два подхода

<div class="grid grid-cols-2 gap-2">

<div class="bg-gray-200 dark:bg-gray-800 p-2 border-rd-4">

### Метод "чёрного ящика"

> Подход, при котором тестировщик **не знает внутреннего устройства системы**. Он проверяет продукт так же, как это делает пользователь - через интерфейсы и требования. То есть, метод проверяет **что делает система**

#### Характеристики

- Тестирование основано на требованиях и спецификациях.  
- Сосредоточено на *входах и выходах* системы.  
- Не учитывает внутренний код.

#### Примеры подходов
- **Эквивалентное разбиение** - входные данные разделяются на группы (классы эквивалентности), внутри которых программа должна вести себя одинаково
- **Анализ граничных значений** - тестирование границ диапазонов допустимых значений
- **Таблицы решений** - описание сложных случаев и их тестирование
- **Тестирование состояний** - проверка состояний и корректности переходов между ними

</div>
<div class="bg-gray-200 dark:bg-gray-800 p-2 border-rd-4">

### Метод "белого ящика"

> Тестирование **с доступом к исходному коду**. Тестировщик понимает, как всё работает внутри, и строит тесты исходя из логики программы. То есть, метод проверяет **как система реализует логику**

#### Характеристики
- Проверка путей выполнения кода.  
- Анализ логики функций, условий, циклов.  
- Оценка покрытия кода тестами.

#### Примеры подходов
- Тестирование всех ветвей (branch coverage)  
- Тестирование всех путей (path coverage)  
- Проверка условий и циклов  

</div>

</div>

---
class: table-dense
---

<style scoped>
  td {
    font-size: 12px;
  }
</style>

# Инструменты тестирования

| Уровень тестирования     | Python инструменты                    | JavaScript инструменты                  | Краткое назначение |
|--------------------------|----------------------------------------|------------------------------------------|----------------------|
| **Статическое** | `flake8`, `pylint`, `mypy`                | `ESLint`, `TypeScript`, `Prettier`       | Анализ стиля, типизации и потенциальных ошибок |
| **Unit-тестирование**    | `unittest`, `pytest`, `nose2`          | `Jest`, `Mocha`, `Vitest`                | Проверка отдельных функций и модулей |
| **Интеграционное**       | `pytest` + fixtures, `requests-mock`   | `Mocha`, `Jest`, `Supertest`             | Проверка взаимодействия компонентов |
| **API-тестирование**     | `pytest`, `requests`, `locust`         | `Supertest`, `Axios` + тест-раннеры      | Тестирование REST/GraphQL API |
| **Системное, E2E/UI**  | `Playwright` (Python), `Selenium`      | `Playwright`, `Cypress`, `Selenium`      | Тесты "как пользователь" для всего приложения, включая UI |
| **Нагрузочное** | `Locust`, `JMeter` (через CLI)         | `k6`, `Artillery`, `JMeter`               | Проверка производительности и стабильности |
| **Тестирование безопасности** | `Bandit`, `pylint` (частично), `OWASP ZAP` (через API) | `npm audit`, `OWASP ZAP`, `Snyk`         | Поиск уязвимостей и проблем безопасности |

---

<style scoped>
  h3 {
    font-weight: 700;
    font-size: 18px;
  }

  p:not(h1 + p), li {
    font-size: 15px;
    line-height: 1.4rem;
  }

  blockquote {
    margin-top: 12px;
  }
</style>

# QA-инженеры - кто это?

> **QA-инженер (Quality Assurance)** — специалист, который отвечает за качество продукта на всех этапах разработки. Его цель - не просто "поймать баги", а выстроить процессы, которые позволяют предотвращать (или по крайней мере минимизировать) ошибки и выпускать надёжный продукт

### Задачи

- **Анализ требований** - проверяет, понятны ли требования, нет ли противоречий, остаются ли пробелы 
- **Планирование тестирования** — определяет стратегию, подходы, необходимые виды тестов
- **Разработка тестовой документации** — чек-листы, тест-кейсы, тест-планы
- **Ручное тестирование** — функциональное, регрессионное, исследовательское
- **Автоматизация тестирования** — создание и поддержка автотестов на разных уровнях
- **Настройка процессов качества**:
  - Участие в CI/CD
  - Контроль тестового покрытия
  - Внедрение тестовых стандартов
  - Мониторинг качества после релиза
- **Работа с дефектами** — создание баг-репортов, трекинг, проверка исправлений
- **Коммуникация с командой** — обсуждение рисков, уточнение требований, участие в планировании

> Также различают ручных (manual) и автотестировщиков (automation): первые тирование только вручную, вторые - ещё и автоматические

---

# Роль разработчиков в тестировании

<div></div>

QA-инженеры - не единственная роль, занимающаяся качеством продукта, хотя и основная. Разработчики тоже участвуют в обеспечении качества:

- **Пишут unit-тесты** для функций и модулей
- **Проводят интеграционные тесты** на уровне сервисов
- **Исправляют найденные баги** и пишут тесты, предотвращающие регрессию
- **Проводят код-ревью**, обращая внимание на потенциальные ошибки
    > **Код ревью (Code Review)** - процесс ручной проверки изменений участниками команды, сделанных в рамках какой-то задачи
- **Поддерживают качество архитектуры**, что напрямую влияет на **тестируемость**
    > **Тестируемость** - крайне важная характеристика ПО, отражающая то, насколько просто его тестировать
- **Иногда пишут и запускают автотесты**, особенно в командах с практиками TDD

---
transition: slide-up
---

# Глоссарий

- **Дефект / Баг (Bug, Defect)** - Несоответствие фактического поведения системы ожидаемому. Ошибка, обнаруженная в продукте
- **Ошибка (Error)** - Неправильное действие разработчика или неправильное решение, которое приводит к дефекту в коде
- **Сбой (Failure)** - Ситуация, когда система перестаёт работать должным образом из-за дефекта и проявляет неверное поведение при исполнении
- **Тест-кейс (Test Case)** - Набор шагов, входных данных и ожидаемых результатов, предназначенный для проверки конкретной функции продукта
- **Чек-лист (Checklist)** - Список проверок без детальных шагов — используется для более свободного тестирования
- **Тест-сьют (Test Suite)** - Набор тест-кейсов, объединённых по признаку: функциональность, релиз, модуль и т.д.
- **Валидация (Validation)** - Ответ на вопрос: *«Мы сделали то, что нужно пользователю?»*

---

- **Верификация (Verification)** - Проверка продукта на соответствование требованиям
- **E2E-тесты (End-to-End)** - Тесты, проверяющие всю систему целиком от лица пользователя
- **Фикстуры (Fixtures)** - Структуры или данные, которые подготавливаются **перед запуском тестов**, чтобы обеспечить предсказуемое и контролируемое окружение. Примеры: пустая база, подготовленные объекты, тестовые директории
- **Моки (Mocks)** - Объекты-заменители, которые **имитируют поведение реальных зависимостей** (БД, API, файлы), чтобы изолировать тестируемую функциональность. Моки позволяют контролировать ответы и проверять, как код взаимодействует с зависимостью
- **Стабы (Stubs)** - Упрощённые реализации зависимостей, которые возвращают заранее определённые данные и не имеют сложной логики
- **Спаи (Spies)** - Инструменты, позволяющие отслеживать вызовы функций: сколько раз вызвана, с какими аргументами и т.д.
- **Mocking / Stubbing / Spying** - Совокупность техник имитации зависимостей в тестах
- **Test Runner** - Инструмент, который выполняет тесты (например: Jest, Mocha, PyTest)
- **Ассерт (Assertion)** - Утверждение, которое проверяет, соответствует ли фактический результат ожидаемому

---

<style scoped>
  h3 {
    font-weight: 700;
    font-size: 16px;
    line-height: 1.5rem;
  }
</style>

# TDD

> **TDD (Test-Driven Development, Разработка через тестирование)** — методология разработки, при котором разработчик сначала пишет тесты, а только потом код программы

<div class="grid grid-cols-3 gap-2 mt-2">

<div class="grid-col-span-2 mt-8">

1. **Красный** - написание теста (который обязательно будет падать, так как пока что нет реализации)
2. **Зелёный** Написание кода, который бы приводил к прохождению тестов
3. **Рефакторинг** - при необходимости. При этом не нужно беспокоиться о поломках, так как тесты уже написаны

</div>

<img src="https://www.xeridia.co.uk/sites/default/files/contenidos/blog/test-driven-development.png" class="dark:filter-invert-[1]" />

</div>

<div class="font-size-3">

### Другие методологии

- **BDD (Behavior-Driven Development)** — поведенческая разработка, фокус на сценариях "Given–When–Then"
- **FDD (Feature-Driven Development)** — фокус на разработке отдельных фич
- **DDD (Domain-Driven Development)** - подход, оносванный на моделировании предметной области (домена), отражающий бизнес-логику

</div>

---

# TDD

Пример

<Arrow v-click="1" v-bind="{ x1: '48%', y1: '50%', x2: '52%', y2: '50%', width: 1.5, color: '#facc15' }" />

<style scoped>
  div {
    --slidev-code-font-size: 9px;
    --slidev-code-line-height: 12px;
  }
</style>

<div class="grid grid-cols-2 gap-10">

```js
describe("formatName - функция форматирования имени", () => {
  test("должна капитализировать имя", () => {
    expect(formatName("alex")).toBe("Alex");
  });

  test("должна убирать лишние пробелы", () => {
    expect(formatName("   maria   ")).toBe("Maria");
  });

  test("должна корректно обрабатывать пустую строку", () => {
    expect(formatName("")).toBe("");
  });

  test("должна возвращать пустую строку для нестроковых значений", () => {
    expect(formatName(null)).toBe("");
    expect(formatName(undefined)).toBe("");
    expect(formatName(123)).toBe("");
  });

  test("должна корректно форматировать имя с несколькими словами", () => {
    expect(formatName("john   doe")).toBe("John Doe");
  });
});
```

<div class="mt-15" v-click="1">

```js
export function formatName(name) {
  if (typeof name !== "string") return "";

  const cleaned = name.trim();
  if (cleaned.length === 0) return "";

  return cleaned
    .split(/\s+/)
    .map((word) => 
      word.charAt(0).toUpperCase() + word.slice(1).toLowerCase()
    )
    .join(" ");
}
```

</div>

</div>

---

<style scoped>
  div {
    --slidev-code-font-size: 9px;
    --slidev-code-line-height: 12px;
  }
</style>

# Мутационное тестирование

<style scoped>
  h3 {
    font-weight: 700;
    font-size: 18px;
  }

  li {
    font-size: 16px;
    line-height: 1.6rem;
  }
</style>

> **Мутационное тестирование (mutation testing)** — это техника оценки качества тестов (так сказать, тестирование тестов ¯\_(ツ)_/¯ ), при которой код **искусственно изменяют** (создают "мутации") и проверяют, могут ли тесты обнаружить изменения

> Если тесты **падают**, мутация считается **убитой** — это хорошо, так как значит, 

> Если тесты **продолжают проходить**, мутация **выжила** — значит тесты написаны плохо

### Зачем нужно?

- Помогает находить недостающие проверки
- Повышает надежность тестового покрытия

<div class="grid grid-cols-3 gap-2">

```js
export function isAdult(age) {
  return age >= 18;
}
```

```js
import { isAdult } from "./isAdult.js";

test("возвращает true для взрослых", () => {
  expect(isAdult(20)).toBe(true);
});

test("возвращает false для несовершеннолетних", () => {
  expect(isAdult(16)).toBe(false);
});
```

<div>

```diff
- return age >= 18;
+ return age > 18;
```

<figcaption class="opacity-[0.5] font-size-3">При такой мутации тесты продолжат проходить, а значит мы не учли такой вариант</figcaption>

</div>

</div>

> Примеры мутационного тестирования можно найти по пути <mark>[`snippets/testing/mutation-test-example`](https://github.com/FloydanTheBeast/hse-lyceum-web-2025/tree/main/snippets/testing/mutation-test-example)</mark> в репозитории проекта

---

# Примеры

<div class="text-align-center mt-40">

**Примеры тестирования можно найти по пути <mark>[`snippets/testing`](https://github.com/FloydanTheBeast/hse-lyceum-web-2025/tree/main/snippets/testing)</mark> в репозитории проекта**

</div>

---

# Практика

1. **Unit-тестирование** - задание описано в [файле <mark>`snippets/testing/unit-tests-exercise.js`</mark> репозитория](https://github.com/FloydanTheBeast/hse-lyceum-web-2025/tree/main/snippets/testing/unit-tests-exercise.js)
2. **TDD** - задание описано в [файле <mark>`snippets/testing/tdd-exercise.spec.js`</mark> репозитория](https://github.com/FloydanTheBeast/hse-lyceum-web-2025/tree/main/snippets/testing/tdd-exercise.spec.js)

---
src: ./_shared.md#1
---

---

# Дополнительные материалы

- [QaTools - Уровни пирамиды тестирования](https://qatools.ru/blog/tpost/pargul2o21-urovni-piramidi-testirovaniya)
- [Хекслет - Курс «Введение в тестирование веб-приложений»](https://ru.hexlet.io/courses/web-testing-basics)
- [Habr - Коду плохо, зовите тестера: что такое санитарное тестирование](https://habr.com/ru/companies/petrovich-tech/articles/875886/)

<br />

> Ещё материалы есть в **README** репозитория