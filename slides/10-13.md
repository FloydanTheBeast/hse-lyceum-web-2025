---
theme: default
title: "React - продолжение / Курс по веб-разработке, 10 класс"
class: text-center
drawings:
  persist: false
transition: slide-left
mdc: true
fonts:
  sans: Montserrat
hideInToc: true
browserExporter: true
---

# Курс по веб-разработке

<h2 class="color-gray-400 fw-200">React - продолжение</h2>

---

<style scoped>
  div {
    --slidev-code-font-size: 8px;
    --slidev-code-line-height: 10px;
  }
</style>

# Мемоизация

>  **Мемоизация** - техника оптимизации, позволяющая сохранять результат работы функции без необходимости её повторного вычисления

```js
function sum(n) {
  return Array.from({ length: n }, (_, i) => i + 1).reduce((acc, val) => acc + val, 0);
}

function memoize(fn) {
  let cache = {};
  return (...args) => {
    // Генерируем ключ для набора аргументов
    // Способ плохой, так как сериализация в JSON - сама по себе дорогая операция
    const key = JSON.stringify(args);

    if (!cache.hasOwnProperty(key)) {
      cache[key] = fn(...args);
    }

    return cache[key];
  }
}

const memoizedSum = memoize(sum);

console.time('not_memoized');
console.log(memoizedSum(1_000_000))
console.timeEnd('not_memoized');

console.time('memoized');
console.log(memoizedSum(1_000_000))
console.timeEnd('memoized');
```

---

# `useMemo`

<div></div>

Хук `useMemo` позволяет мемоизировать результат вычисления какой-то функции и пересчитывать его только в том случае, если изменилась какая-то из зависимостей

```jsx
import { useMemo } from 'react'

function Page({ items, status }) {
  const filteredItems = useMemo(() => {
    return items.filter(item => item.status === status)
    // Массив зависимостей
    // Если одна из них изменится, то функция пересчитается
  }, [items, status])

  return filteredItems.map((item) => { ... })
}
```

В отличие от мемоизации из предыдущего примера, "запоминается" (или кэшируется) только последнее значение

> `useMemo` не стоит использовать постоянно, а прибегать к нему только тогда, когда возникают проблемы с производительностью, так мемоизация сама по себе несёт накладные расходы и усложняет код

---

# `useCallback`

<div></div>

Хук `useCallback` - аналог `useMemo`, но мемоизирует переданную функцию

```jsx
function App() {
  const [query, setQuery] = useState('react')

  const fetchData = useCallback(async () => {
    console.log('Запрос:', query)
    // fetch(...)
  }, [query])

  useEffect(() => {
    fetchData()
  }, [fetchData]) // Cрабатывает только при изменении query

  return (
    <input
      value={query}
      onChange={e => setQuery(e.target.value)}
    />
  )
}
```
---

# `React.memo`

Функция `React.memo` мемоизирует компонент - в таком случае он (почти) никогда будет перерендериваться вместе с родителем (это не гарантируется, иногда всё равно может)

```jsx
function Parent() {
  const [count, setCount] = useState(0);

  return <>
    <p>Счётчик: {count}</p>
    <button>Увеличить</button>
    <VeryExpensiveChild />
  </>
}

const VeryExpensiveChild = React.memo(() => {
  return <ul>
      {Array.from({ length: 100_000 }, (_, i) => i).map(i => <li>{i}</li>)}
    </ul>
})
```

> Вторым аргументом функции `memo` можно передать собственную функцию-компаратор `arePropsEqual(oldProps, newProps)`, которая будет использована для сравнения старых и новых пропов и, соответственно, для проверки необходимости перерендера

---

# Паттерн - HOC

> **Паттерн** - шаблонный, общепринятый подход к решению какой-то задачи

> **HOC (Компоненты высшего порядка, Higher-Order Components)** - шаблон (паттерн) разработки. Компоненты, принимающие в себя другие компоненты в качестве входа и возвращающие новый компонент в качестве выхода. `React.memo` - пример одного из них

### Для чего это нужно?

- **Переиспользуемость** - позволяет использовать одну и ту же логику для любого компонента
- **Расширение** - позволяет добавить новую логику для существующего компонента
- **Инкапсуляция** - позволяет объединить данные (состояние), логику работы и отображение в одном компоненте, ограничивая доступ и детали реализации от разработчика

```jsx
function withFancyStyles(Component) {
  return <Component style={{ color: 'red', background: 'blue' }} />
}

const Button = () => <button>Кнопка</button>

const FancyButton = withFancyStyles(Button);

```

---

<style scoped>
  div {
    --slidev-code-font-size: 9px;
    --slidev-code-line-height: 10px;
  }
</style>

# `useRef`

<div></div>

Хук `useRef` позволяет создать мутируемое значение (возвращает объект вида `{ current: <значение> }`), которое компонент должен сохранить и "запомнить", но при этом не перерендериваться при изменении этого значения. Обычно используются для:
- Хранения значения, которое не используется для отображения
- Получения и хранения DOM-элемента для последующих манипуляций


<div class="grid grid-cols-2 gap-2">

```jsx
import { useRef } from 'react';

function Counter() {
  let ref = useRef(0);

  function handleClick() {
    ref.current = ref.current + 1;
    alert('Вы кликнули ' + ref.current + ' раз!');
  }

  return (
    <button onClick={handleClick}>
      Нажми сюда
    </button>
  );
}
```

```jsx
import { useRef } from 'react';

function Form() {
  const inputRef = useRef(null);

  function handleClick() {
    inputRef.current.focus();
  }

  return (
    <>
      <input ref={inputRef} />
      <button onClick={handleClick}>
        Активировать поле ввода
      </button>
    </>
  );
}

```

</div>

---

<style scoped>
  div {
    --slidev-code-font-size: 9px;
    --slidev-code-line-height: 10px;
  }
</style>

# Context API

<div></div>

`Context API` позволяет дочерним компонентам получать значения из предков без необходимости передавать их через пропы. Полезен, когда дерево комопентов становится глубоким и пропы необходимо передавать через несколько уровней - это **антипаттерн, называющийся "prop drilling"**

<div class="grid grid-cols-2 gap-2">

```jsx
function App() {
  const [theme, setTheme] = useState('light');

  return <Page theme={theme} />
}

function Page({ theme }) {
  return <><Header theme={theme} /></>
}

function Header({ theme }) {
  return <header style={{ color: theme == 'light' ? 'black' : 'white'}}>
    Шапка
  </header>
}
```

```jsx
const ThemeContext = React.createContext('light')

function App() {
  const [theme, setTheme] = useState('light');

  return <ThemeContext.Provider value={theme}>
    <Page />
  </ThemeContext.Provider>
}

function Page() {
  return <><Header /></>
}

function Header() {
  // `useContext` будет искать ближайший Provider
  //  переданного объекта контекста
  const theme = useContext(ThemeContext);

  return <header style={{ color: theme == 'light' ? 'black' : 'white'}}>
    Шапка
  </header>
}
```

</div>

---

<style scoped>
  div {
    --slidev-code-font-size: 11px;
    --slidev-code-line-height: 11px;
  }
</style>

# Пользовательские хуки

<div></div>

Помимо предоставляемых React'ом хуков, можно писать и свои собственные, это позволяет:
- Переиспользовать логику
- Делать код компонентов более читаемым
- Иметь единую точку для будущих изменений

<div class="grid grid-cols-2 gap-2">

```jsx
const useFetch = (url) => {
  const [data, setData] = useState()
  const [isLoading, setIsLoading] = useState(true);
  const [hasError, setHasError] = useState(false)

  useEffect(() => {
    fetch(url)
      .then(data => data.json())
      .then(data => setData(data))
      .catch(() => setHasError(true))
  }, [])

  return {
    data,
    isLoading,
    hasError
  }
}
```

```jsx
function GitHubProfile() {
  const { data, isLoading, hasError } =
    useFetch('https://api.github.com/users/floydanthebeast')

  if (isLoading) {
    return 'Загрузка';
  }

  if (hasError) {
    return 'Произошла ошибка'
  }

  return <>{data.login} - {data.id}</>
}
```

</div>

---

# React Router

> **React Router** — библиотека для клиетской навигации (маршрутизации) в **одностраничных приложениях (Single Page Application, SPA)** без перезагрузки страницы

<br />

### Основные возможности
- Клиентский роутинг
- Динамические параметры URL
- Работа с параметрами запроса
- Вложенные маршруты
- Программная навигация
- Поддержка разных видов маршрутизации (браузерной, in-memory, hash, static)
- и другие...

---

<style scoped>
  div {
    --slidev-code-font-size: 9px;
    --slidev-code-line-height: 10px;
  }
</style>

# React Router

Создание маршрутизатора

<div class="grid grid-cols-2 gap-2">

<div>

```jsx
import { BrowserRouter, Routes, Route } from 'react-router'

function App() {
  return (
    <BrowserRouter>
      <Routes>
        {/* Описание маршрутов */}
        <Route path="/" element={<Home />} />
        <Route path="/users" element={<Users />} />
        <Route path="/users/:id" element={<UserDetails />} />
        {/* Любой несуществующий маршрут */}
        <Route path="*" element={<NotFound />} />
      </Routes>
    </BrowserRouter>
  )
}
```

<figcaption>Декларативный подход</figcaption>

</div>
<div>

```jsx
import { createBrowserRouter, RouterProvider } from "react-router";

let router = createBrowserRouter([
  {
    path: "/",
    Component: Home,
  },
  {
    path: '/users'
    Component: Users,
  },
  {
    path: '/users/:id',
    Component: UserDetails,
  },
  {
    path: '*',
    component: NotFound
  }
]);

ReactDOM.createRoot(root).render(
  <RouterProvider router={router} />,
);
```

<figcaption>Более современный подход, позволяющий пользоваться некоторыми нововведениями</figcaption>

</div>

</div>

---

# React router

Навигация

```jsx
import { NavLink, generatePath } from 'react-router'

const ROUTES = {
  root: '/',
  userDetails: '/users/:id'
}

function AppMenu() {
  const currentUserId = 1;

  return <ul>
    <NavLink to={ROUTES.root}>Главная</NavLink>
    <NavLink to={generatePath(ROUTES.userDetails, currentUserId)}>Профиль</NavLink>
  </ul>
}
```

---

# React router

Хуки

- `useNavigate()` - возвращает функцию, позволяющую изменить текущий маршрут программно
- `useMatch(pattern)` - возвращает объект, если переданный `pattern` соответствует текущему пути, иначе - `null`
- `useParams()` - возвращает объект с динамическими параметрами текущего пути (например, `{ id: <значение> }` для `/users/:id`)
- `useLocation()` - возвращает объект с информацией о текущей локации
- `useSearchParams()` - возвращает массив вида `[searchParams, setSearchParams]`, где:
  - `searchParams` - объект с параметрами поиска
  - `setSearchParams` - функция для изменения параметров поиска
- и другие...

---

# Стилизация компонентов

Классический CSS

Можно подключить стили через тэг `link`, либо импортировать прямо в JS (этим занимается сборщик, vite по умолчанию поддерживает такой способ)

```jsx
import './App.css';

function App() {
  return <div className="container">Классический CSS</div>;
}
```

Самый простой и привычный способ, но он может приводить к конфликтам классов

---

# Стилизация компонентов

Inline-стили

```jsx
function InlineStyled() {
  return (
    <div style={{ color: 'white', backgroundColor: 'blue', padding: '10px' }}>
      Пример inline-стиля
    </div>
  );
}
```

- Легко использовать динамические стили
- Не поддерживает псевдоклассы (`:hover` и т.п.) и медиа-запросы

---

# Стилизация компонентов

CSS-модули

Файлы вида `*.module.css` с локальными классами, импортируемые в компонент. Поддержкой CSS-модулей так же занимается сборщик, браузеры такого не поддерживают

```jsx
// styles - объект, ключами которого являются классы, объявленные в css-файле
import styles from './Button.module.css';

function Button() {
  return <button className={styles.primary}>Нажми на меня</button>;
}
```

- Каждый модуль изолирован от всех остальны, что упрощает управление стилями в крупных проектах, так как каждый компонент имеет свои собственные
- Классы локальны по умолчанию - сборщик самостоятельно сгенерирует уникальные названия классов на основе тех, что указаны в css-файле
- Избавляет от конфликтов имен классов

---

# Стилизация компонентов

CSS-in-JS библиотеки

Есть множество различных библиотек, позволяющих стилизовать компоненты при помощи JS, например:
- [`styled-components`](https://styled-components.com/)
- [`jss`](https://cssinjs.org/?v=v10.10.1)
- [`emotion`](https://emotion.sh/docs/introduction)
- и другие...

<div class="grid grid-cols-2 gap-2">

```jsx
import styled from 'styled-components';

const Button = styled.button`
  background-color: blue;
  color: white;
  padding: 10px;
`;

function App() {
  return <Button>Styled Button</Button>;
}
```

<div>

- Позволяют использовать динамические стили
- Легко создавать переиспользуемые компоненты
- Разные инструменты обладают дополнительными полезными возможностями (определение темы, переиспользование стилей и другие)

</div>

</div>

---

# React Developer Tools

<img src="https://lh3.googleusercontent.com/XWuZGqIrIsaoKHUqqQ2rs_GhS5JaH1p5pPBIUpj22mjNRNdR3Ana8FKz4B7JwsA6HIFVXGuU7pa4ELiW6iUNhs0Iyg=s1600-w1600-h1000" class="w-150 mx-auto" />
<figcaption>React Developer Tools - браузерное расширение для дебага react-приложения, включающее профилировщик</figcaption>

<a class="block w-60 mx-auto" href="https://ru.react.dev/learn/react-developer-tools">Ссылка на документацию</a>

---
layout: cover
---

# Live-кодинг

---

# Практика

<div></div>

Решаем [задачу со второго отборочного этапа PROD'а](https://github.com/Central-University-IT/FAQ-2025/blob/main/frontend/task/task.md) 2025-го, но с упрощёнными условиями:
- Должны быть доступны страницы:
  - Переход по пути `/` автоматически перенаправляет на `/tests`
  - Список тестов (достаточно 2-х штук) - `/tests`
  - Страница с конкретным тестом - `/tests/:id?question={}` (id теста - динамический параметр, номер открытого вопроса - параметр запроса `question`)
  - Страница 404
- Используем React и React router
- Можно использовать любые подходы для стилизации
- Завершение теста сразу открывает модальное окно с результатами

---
src: ./_shared.md#1
---

---

# Дополнительные материалы

- [MyJavascript - Шпаргалка по использованию хуков](https://my-js.org/docs/cheatsheet/react-hooks)
- [ReactDev.ru - Учебное пособие по React Router v6](https://reactdev.ru/libs/react-router.6/tutorial/) - туториал по созданию приложения с использованием react router
- [FreeCodeCamp - How to Use React Developer Tools – Explained With Examples](https://www.freecodecamp.org/news/how-to-use-react-devtools/)