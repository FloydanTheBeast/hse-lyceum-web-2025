---
theme: default
title: JS - Забытые темы / Курс по веб-разработке, 10 класс
class: text-center
drawings:
  persist: false
transition: slide-left
mdc: true
fonts:
  sans: Montserrat
hideInToc: true
browserExporter: true
---

# Курс по веб-разработке

<h2 class="color-gray-400 fw-200">JS - Забытые темы</h2>

---
transition: none
---

# Логические операторы

`!` - "не"

```js
!true // false
!0 // true
!1 // false
!"" // true
!null // true
!undefined // true
!"какая-то строка" // false

!!null // false
!!"какая-то строка" // true
```

`!` - неявно приводит тип к логическому значению (bool) и возвращает противоположное. 

`!!` - двойное отрицание, приводит тип к `Boolean`. Его можно использовать как короткую запись `Boolean(...)`

---
transition: none
---

<style scoped>
  blockquote {
    margin: 8px 0;

    p {
      font-size: 12px;
      line-height: 1.1rem;
    }
  }

  div {
    --slidev-code-font-size: 11px;
    --slidev-code-line-height: 12px;
  }
</style>

# Логические операторы

`||` - "или"

```js
false || false // true
false || true // true
true || false // true
true || true // true
0 || 1 // 1
0 || "Какая-то строка" // "Какая-то строка"
0 || false || [1, 2, 3] // [1, 2, 3]
false || 0 || '' || null // null
```

> В JS `||` возвращает **первое истинное значение**, при этом оно не обязатель долнжо быть логическим, главное чтобы оно равнялось `true` при приведении к `Boolean`. Если истинных значений в выражении нет, то вернётся последнее

```js
const a = () => ''
const b = () =>  'Строка'
const c = () => [1, 2, 3]

const result = a() || b() || c()
console.log(result) // 'Строка'
```

> Выражение `a() || b() || c()` вернёт первое истинное значение, то есть `'Строка'`, при этом функция `c` не вызовется. Это называется **"ленивым вычислением"**: часть выражения, которую не нужно вычислять для получения результата, попросту отбрасывается

---

# Логические операторы

`&&` - "и"

```js
false && false // false
false && true // false
true && false // false
true && true // true

0 && 'Строка' // 0
1 && 'Строка' // 'Строка'

const fn = () => { ... }

false && 0 && fn() // Функция `fn` не вызовется
true && 'Строка' && fn() // Функция `fn` вызовется
```

> Аналогично с `||`, оператор `&&` - ленивый, то есть расчёт выражения прекратится, как только найдётся первое ложное значение. Если все значения истины, то вернётся последнее

---

<style scoped>
  h1 {
    font-size: 32px;
  }

  p {
    font-size: 12px;
    line-height: 1.1rem;
    margin: 4px 0;
  }

  div {
    --slidev-code-font-size: 12px;
    --slidev-code-line-height: 14px;
  }
</style>

# Оператор нулевого слияния и присваивания

<div></div>

**Оператор нулевого слияния `??` (Nullish coalescing operator)** позволяет проверить, является ли значение определённым (то есть не равным `undefined` или `null`) и, в случае если нет, вернуть другое значение

```js
let user1 = { firstName: 'Иван', lastName: 'Иванов', email: 'iivanov@example.com' }
let user2 = { email: 'anonymous@example.com' }

console.log(user1.firsName ?? user1.lastName ?? user1.email) // 'Иван'
console.log(user2.firsName ?? user2.lastName ?? user2.email) // 'anonymous@example.com'

let a = ''
let b = 'Строка'

console.log(a ?? b) // ''
// Аналогичный код
console.log((a !== null && a !== undefined) ? a : b)
```

**Оператор нулевого присваивания (Nullish coalescing assignment)** позволяет присвоить значение переменной, если она не определена

```js
let user = null;

user ??= { firstName: 'Иван' }
// Аналогичный код
if (user === undefined || user === null) {
  user = { firstName: 'Иван' }
}
```

---

<style scoped>
  p {
    font-size: 12px;
    line-height: 1.1rem;
  }

  div {
    --slidev-code-font-size: 11px;
    --slidev-code-line-height: 12px;
  }
</style>

# Опциональные цепочки

<div></div>

При обращении к несуществующим свойствам объектов JS возвращает `undefined`. Однако если попробовать получить любое свойство у `null` или `undefined`, то выбросится исключение - `Cannot read properties of null/undefined`. Для таких случае можно использовать **оператор опциональной цепочки (Optional chaining)**:

```js {*}{maxHeight:'320px'}
class User {
  constructor(name, address) {
    this.name = name;
    if (address) {
      this.info = { address }
      this.printInfo = function () {
        console.log(`${this.name} живёт по адресу: ${this.info.address}`)
      }
    }
  }
}

let user1 = null

console.log(user1.name) // Uncaught TypeError: Cannot read properties of undefined (reading 'name')
console.log(user1?.name) // undefined

let user2 = new User('Иван')

console.log(user2.info.address) // Uncaught TypeError: Cannot read properties of undefined (reading 'address')
console.log(user2.info?.address) // undefined
user2.printInfo() // Uncaught TypeError: user2.printInfo is not a function
user2.printInfo?.() // undefined

let user3 = new User('Иван', 'Москва')
console.log(user3.info?.address) // 'Москва'
user3.printInfo() // 'Иван живёт по адресу: Москва'

let array1 = null
console.log(array[0]) // Cannot read properties of null (reading '0')
console.log(array?.[0]) // undefined

let usersArray = [user1, user2, user3];
console.log(usersArray?.[4]?.info?.address) // undefined
```

> Оператор опциональной цепочки (`?.`) обеспечивает **безопасный доступ к свойствам** - если какая-то из частей цепочки равна `null` или `undefined`, то вернётся `undefined` и не будет ошибки

---

<style scoped>
  li {
      font-size: 12px;
      line-height: 1.1rem;
      margin: 8px 0;
  }

  div {
    --slidev-code-font-size: 9px;
    --slidev-code-line-height: 12px;
  }
</style>


# Spread

> **Spread-оператор (`...`)** - специальный синтаксис JS, позволяющий добавить в итерируемый объект (массив или объект) новые элементы

- **С массивами**
  ```js
  const arr1 = [1, 2, 3]
  const arr2 = [5, 6, 7]

  const newArr = [0, ...arr1, 4, ...arr2];
  console.log(newArr); // [0, 1, 2, 3, 4, 5, 6, 7]
  ```
- **С объектами**
  ```js
  const userMainInfo = { name: 'Иван Иванов' }
  const userAdditionalInfo = { email: 'iivanov@example.com' }

  const user = {
    ...userMainInfo,
    ...userAdditionalInfo,
    age: 18
  }
  console.log(user); // { "name": "Иван Иванов", "email": "iivanov@example.com", "age": 18 }
  ```
- **С функциями** - позволяет передать элементы массива в качестве аргументов. `i`-ый элемент массива передастся как `i`-ый аргумент функции
  ```js
  const sum = (a, b, c) => a + b + c;

  console.log(sum(...[1, 2, 3, 4, 5])) // 6
  ```

---

<style scoped>
  div {
    --slidev-code-font-size: 10px;
    --slidev-code-line-height: 12px;
  }
</style>


# Деструктуризация массивов и объктов

> **Деструктуризация** - специальный синтаксис JS, позволяющий "распаковать" (т.е. достать и переложить) значение массива (или любой коллекции, например `Set`) или объекта в отдельную переменную

<div class="grid grid-cols-2 gap-2">

<div>

```js
const array = [1, 2, 3, 4, 5]

const [a, b, ...rest] = array;

console.log(a, b, rest); // 1 2 [3, 4, 5]

```

```js
// Можно указывать значения по умолчанию
const [a = 1, b = 2, ...rest] = [];

console.log(a, b, rest); // 1 2 []
```

```js
const [a, b, ...rest] = new Set([1, 2, 3, 4, 5])

console.log(a, b, rest); // 1 2 [3, 4, 5]
```

</div>

<div>

```js
const user = { name: 'Иван', email: 'iivanov@example.com', age: 18, isActive: true };

const {
  // Свойства можно переименовывать
  name: firstName,
  // Можно указывать значения по умолчанию для отсутствующих свойств
  lastName = 'Иванов',
  email,
  ...rest
} = user;

console.log(firstName, lastName, email, rest); // Иван Иванов iivanov@example.com { "age": 18, "isActive": true }
```

```js
function showMenu({ title = "Меню", width = 800, height = 600 } = {}) {
  console.log( `${title} размером ${width} на ${height} пикселей` );
}

showMenu(); // Меню размером 800 на 600 пикселей
```

</div>
</div>

> При деструктуризации можно использовать `...` - rest-оператор (почти как spread). Он соберёт все оставшиеся элементы массива (или другой коллекции) в новый массив, а объекта - в новый объект

---

<style scoped>
  blockquote {
    margin-top: 8px;
  }
</style>

# Стилизация при помощи JS

- Изменение inline-стилей (задающихся при помощи атрибута `style` в html)
  ```js
  const box = document.querySelector('.box');
  box.style.backgroundColor = 'lightblue';
  box.style.width = '200px';
  // Или
  box.style.setProperty('background-color', 'lightblue');
  box.style.setProperty('width', '200px');
  ```
- Добавление и удаление CSS-классов
  ```js
  box.classList.add('active'); // Добавление класса
  box.classList.remove('hidden'); // Удаление класса
  box.classList.toggle('highlight'); // Переключение класса (если его нет, то он добавится, если есть - удалится)
  ```
- Работа с CSS-переменными
  ```js
  document.documentElement.setProperty('--theme', 'dark'); // Создание переменной
  document.documentElement.getPropertyValue('--theme'); // Получение значения
  ```
  > **P.S.** CSS-переменные обычно глобальные, то есть хранятся в корневом элементе - `<html>`. В JS его можно получить при помощи `document.documentElement`, в CSS - селектором `:root {}`

---
transition: none
---

<style scoped>
  blockquote, p {
      font-size: 11px;
      line-height: 1rem;
      margin: 8px 0;
  }

  div {
    --slidev-code-font-size: 9px;
    --slidev-code-line-height: 12px;
  }
</style>

# JSON

> **JSON (JavaScript Ojbect Notation)** - специальный стандартный формат представления данных, основанный на синтаксисе объектов в JS. Обычно используется для передачи данных по сети и файлов с конфигурациями (настройками). JSON-файлы имеют расширение `.json`

Основные типы данных для организации JSON - **объекты** (набор пар "ключ-значение") и **массивы**. Примеры JSON-файлов:

<div class="grid grid-cols-2 gap-2">
  
```json
{
  "user": {
    "id": 12345,
    "name": "Иван Иванов",
    "email": "iivanov@example.com",
    "isActive": true
  },
  "orders": [
    {
      "orderId": 1001,
      "date": "2025-10-15",
      "items": [
        { "product": "Ноутбук", "price": 30000, "quantity": 1 },
        { "product": "Мышь", "price": 1000, "quantity": 2 }
      ],
    },
    {
      "orderId": 1002,
      "date": "2025-10-16",
      "items": [
        { "product": "Клавиатура", "price": 2000, "quantity": 1 }
      ],
    }
  ]
}
```

```json
[
  {
    "id": 12345,
    "name": "Иван Иванов",
    "email": "iivanov@example.com"
  },
  {
    "id": 12346,
    "name": "Саша Кузнецов",
    "email": "akuznetsov@example.com"
  }
]
```

</div>

---

<style scoped>
  blockquote, p {
      font-size: 12px;
      line-height: 1.1rem;
      margin: 8px 0;
  }

  div {
    --slidev-code-font-size: 10px;
    --slidev-code-line-height: 12px;
  }
</style>

# JSON

<div></div>

В JS для работы с JSON используется одноимённый класс. `JSON.stringify()` - **сериализует** переданное значение в JSON-строку, `JSON.parse` - наоборот, **десериализует**

```js 
const players = [
  {
    nickname: 'CrazyVanya2009',
    email: 'vanya2008@example.com'
    age: 16,
  },
  {
    nickname: 'Destr0yeR',
    email: 'krutoy_chel@mail.ru'
    age: 13
  },
]

// Сериализация в JSON
const userJson = JSON.stringify(user);

// Десериализация JSON
const deserializedUser = JSON.parse(userJson)
```

> **Сериализация** - преобразование объекта или какой-то структуры данных в какой-либо формат, пригодный для передачи (например, по сети) или хранения вне программы (например, в файле или в базе данных). Пример таких форматов: собственно JSON, двоичный формат, XML и другие. Обратный сериализации процесс называется **десериализацией**

---

<style scoped>
  li, p {
    font-size: 10px;
    line-height: 1rem;
    margin: 4px 0;
  }

  div {
    --slidev-code-font-size: 9px;
    --slidev-code-line-height: 12px;
  }
</style>

# Копирование ссылочных типов

<div></div>

Как вы помните, переменные, указывающие на ссылочные типы (объекты и массивы), хранят только ссылку на адрес памяти. Это значит, что при присвоении ссылочного типа другой переменной адрес и, соответственно, значение будут теми же:

```js
const user = { name: 'Иван', email: 'iivanov@example.com' }
const user2 = user;

user2.name = 'Саша';

console.log(user); // { name: 'Саша', email: 'iivanov@example.com' }
```

Но иногда бывает необходимо скопировать значение ссылочного, чтобы не менять исходное. Этот процесс называется **копированием** или **клонированием**. Копирование называется **глубоким**, если в том числе копируются все вложенные ссылочные типы

```js
const user1 = { name: 'Иван', email: 'iivanov@example.com' }
const user2 = { name: 'Саша', email: 'iivanov@example.com', brothers: [user1] };
```

<div class="grid grid-cols-2 gap-4">

<div>

1. **Spread-оператор** создаёт новый объект (или массив) с такими же свойствами и значениями. Копирование **не глубокое**
  ```js
  const user2Copy = { ...user2 };
  ```
2. `Object.assign` - метод, копирующий . Копирование **не глубокое**
  ```js
  // 1-ый аргумент - целевой объект, в который скопируются 
  // все свойства объектов, переданных следующими аргументами
  const user2Copy = Object.assign({}, user2);
  ```

</div>
<div>

3. `JSON` - глубокое копирование
  ```js
  const user2Copy = JSON.parse(JSON.stringify(user2));
  ```
  Это медленный способ, вдобавок он не работает "сложными" объектами (`Date`, `Set`, `Map` и т.п.)

4. `structuredClone` - глубокое структурное копирование
  ```js
  const user2Copy = structuredClone(user2); 
  ```
  Самый современный и надёжный способ, работающий с любыми вложенными структурами

</div>
</div>

---
transition: none
---

<style scoped>
  h3 {
    font-size: 20px;
    line-height: 1.6rem;
  }

  li, p {
    font-size: 10px;
    line-height: 1rem;
  }

  p {
    margin: 4px 0;
  }

  div {
    --slidev-code-font-size: 9px;
    --slidev-code-line-height: 12px;
  }
</style>

# Хранение данных в браузере

<div class="grid grid-cols-3 gap-2 mb-2">

<div class="p-4 bg-gray-200 dark:bg-gray-800 border-rd-4">

### `localStorage`

- Хранит данные в виде пар "ключ-значение". И ключи, и значения хранятся **только в виде строк**
- Имеет ограничение объёма хранимых данных - ~5МБ (в зависимости от браузера)
- Данные хранятся **постоянно** до ручной очистки
- Объект `localStorage` один на все вкладки и окна браузера для одного источника (т.е. сайта с одинаковым адресом). Это означает, что при помощи `localStorage` можно "общаться" между разными вкладками одного приложения

```js
localStorage.setItem('key', 'value');
localStorage.getItem('key');
localStorage.removeItem('key');
localStorage.clear();
```

Примеры использования:
- Пользовательские настройки
- Состояние приложения

</div>

<div class="p-4 bg-gray-200 dark:bg-gray-800 border-rd-4">

### `sessionStorage`

Практически идентичен `localStorage`, за исключением следующего:
- Хранит данные только в рамках текущей вкладки
- Очищается при закрытии вкладки (при перезагрузке сохраняются)

```js
sessionStorage.setItem('key', 'value');
sessionStorage.getItem('key');
sessionStorage.removeItem('key')
sessionStorage.clear();
```

Используется крайне редко

</div>

<div class="p-4 bg-gray-200 dark:bg-gray-800 border-rd-4">

### Cookie (Куки)

- Хранится в свойстве `document.cookie` в виде строки, содержащей набор пар "ключ-значение":
  ```
  key1=value1;key2=value2
  ```
- Автоматически отправляются вместе с сетевыми HTTP-запросами на сервер в заголовке `Cookie`. Обычно используются для авторизации пользователя
- Автоматически устанавливаются сервером при помощи заголовка `Set-Cookie`
- Имеет ограничение объёма хранимых данных - ~4КБ (в зависимости от браузера)

<br />

> **P.S.** О куках и заголовках более подробно будем говорить позже, когда речь пойдёт о разработке серверных приложений

</div>

</div>

> При установке значения в хранилище на других страницах того же сайта срабатывает глобальное событие `'storage'`<br />
> Помимо перечисленных хранилищ есть ещё `IndexedDB` и `Cache`, но их используют редко, так что изучать мы их не будем

---

# Хранение данных в браузере

> Посмотреть и редактировать данные хранилищ можно в разделе "Приложение" ("Application") инструментов разработчика

<img src="/devtools-storages.png" class="w-62% mx-auto" />

---

<style scoped>
  p {
    font-size: 12px;
    line-height: 1.1rem;
  }
</style>

# Пользовательские события

<div></div>

Помимо событий, генерируемых самимим браузером, есть возможность создавать свои собственне, то есть пользовательские (**Custom Events**). Это может быть полезно, если мы разделяем элементы интерфейса на отдельные компоненты (например, в виде отдельных классов) и события должны относиться к конкретным компонентам, либо если в объект события нужно добавить какие-то новые данные

```js
// Для создания кастомных событий используется класс `CustomEvent`
// Он почти аналогичен обычному `Event`, но имеет дополнительное свойство `detail`
const addTodoEvent = new CustomEvent('addTodo', {
  bubbles: true, // Подвержено ли событие всплытию
  cancelable: true, // Если не указать, событие нельзя будет отменить при помощи `preventDefault`
  detail: { todoId: 1 } // Специальное свойство, содержащее дополнительные данные
});

// Добавление обработчика события
document.addEventListener('addTodo', (e) => {
  console.log('Добавлена новая задача:', e.detail.todoId);
});

// Генерация события
// Таким образом можно вызывать и обычные браузерные события
document.dispatchEvent(addTodoEvent);
```

---

<style scoped>
  p {
    font-size: 12px;
    line-height: 1.1rem;
  }

  div {
    --slidev-code-font-size: 10px;
    --slidev-code-line-height: 12px;
  }
</style>

# Основы сетевых запросов

<div></div>

Чаще всего бразузерные веб-приложения работают с серверами, которые хранят данные и позволяют их запрашивать. JS позволяет отправлять сетевые запросы на сервер, получать данные и соответствующим образом обновлять интерфейс без перезагрузки страницы. Для этого используется функция `fetch`:

```js
async function loadCatsData() {
  try {
    // Делаем GET-запрос по указаному адресу
    const response = await fetch('https://meowfacts.herokuapp.com/');

    // Проверяем, что сервер не вернул ошибку
    if (!response.ok) {
      throw new Error('Ошибка при запросе!')
    }
    
    // Получаем JSON ответа
    const data = await response.json();

    return data;
  } catch (error) {
    console.log(`Произошла ошибка: ${error}`)
  }

}

loadCatData().then(console.log)
```

> Что такое `GET`, заголовки и т.п. подробно изучать будем чуть позже. Сейчас достаточно знать, что **можно отправить запрос на какой-то адрес и получить данные или ошибку в качестве ответа**

---

<style scoped>
  li {
      font-size: 12px;
      line-height: 1.2rem;
  }

  div {
    --slidev-code-font-size: 9px;
    --slidev-code-line-height: 12px;
  }
</style>

# Практика

1. Напишите функции:
    1. Принимающую сколько угодно массивов пользователей и объединяющую их в один при помощи **spread-оператора**, а так же оставляющую только активных пользователей
    ```js
    function combineAndfilterActiveUsers(array1, array2, ...) { ... }

    const defaultSettings = {  }

    const usersArray1 = [{ name: 'Ваня', isActive: true }, { name: 'Саша', isActive: false }];
    const usersArray2 = [{ name: 'Вася', isActive: false }];

    console.log(usersArray1, usersArray2, []); // [{ name: 'Ваня', isActive: true }]
    ```
    2. Принимающую объект пользователя и выводящую в консоль сообщение `{name} является (не)активным пользователем`. **Используйте деструктуризацию**
    ```js
    function logUserStatus(user) { ... }
    ```
    3. Принимающую объект пользователя и возвращающую новый объект с дополненным свойством настроек. **Используйте копирование и spread-оператор**
    ```js
    const DEFAULT_SETTINGS = { theme: 'light',  todos: [] }

    function addDefaultSettingsToUser(user) { ... }

    addDefaultSettingsToUser({ name: 'Ваня' }); // { name: 'Ваня', settings: { theme: 'light',  todos: [] } }
    addDefaultSettingsToUser({ name: 'Саша', settings: { theme: 'dark' } }); // { name: 'Ваня', settings: { theme: 'dark',  todos: [] } }
    ```
2. Дополните код прошлого домашнего задания (списка дел) таким образом, чтобы при перезагрузке страницы сохранялись:
    - Все дела из списка
    - Текущий выбранный фильтр

---
src: ./_shared.md#1
---

---

# Дополнительные материалы

- [learn.javascript.ru - Копирование объектов и ссылки](https://learn.javascript.ru/object-copy)
- [Doka - Хранение данных в браузере](https://doka.guide/tools/browsers-storages/)
- [learn.javascript.ru - LocalStorage, sessionStorage](https://learn.javascript.ru/localstorage)
- [Doka - fetch()](https://doka.guide/js/fetch/)