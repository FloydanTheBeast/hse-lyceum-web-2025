---
theme: default
title: "CSS: анимации и БЭМ. JS: основы Web API и асинхронность / Курс по веб-разработке, 10 класс"
class: text-center
drawings:
  persist: false
transition: slide-left
mdc: true
fonts:
  sans: Montserrat
hideInToc: true
browserExporter: true
---

# Курс по веб-разработке

<h2 class="color-gray-400 fw-200">CSS: анимации и БЭМ.<br />JS: основы Web API и асинхронность</h2>

---
layout: iframe-right
url: html/animation.html
transition: none;
---

<style scoped>
  p:not(h1 + p), li {
    font-size: 12px;
    line-height: 1.1rem;
  }
</style>

# CSS

Анимации

Анимации создаются при помощи директивы `@keyframes`, в которой описываются значения свойств на определённом этапе анимации:

```css
@keyframes <название-анимации> {
  from: { ... }

  to: { ... }
  /* Или */
  0% { ... }

  50% { ... }

  100% { ... }
}
```

> Аналогично свойству `transition`, анимация свойств, связанные с изменением положения или размера (`left`, `top`, `width` и т.п.) плохо влияют на производительность, так как браузер должен пересчитывать размеры всех элементов. **Не относится к `transform`**

---

<style scoped>
  li {
    font-size: 14px;
    line-height: 1.3rem;
  }
</style>

# CSS 

Анимации

- `animation-name` - название анимации (`@keyframes`)
- `animation-duration` - длительность анимации
- `animation-iteration-count` - количество воспроизведений (либо число, либо `infinite`)
- `animation-direction` - направление анимации
  - `normal` (по умолчанию) - от начала до конца
  - `reverse` - обратный порядок
  - `alternate` - от начала до конца, потом снова до начала
  - `alternate-reverse` - от конца до начала, потом снова до конца
- `animation-timing-function` - функция определения скорости анимации (аналогична `transition`)
- `animation-delay` - время задержки воспроизведения
- `animation-play-state` - состояние анимации, `running` или `paused`
- `animation-fill-mode` - применение стилей кадров по умолчанию
  - `none` - стили анимации не применяются
  - `forwards` - после окончания анимации сохранятся стили последнего кадра
  - `backwards` - после окончания анимации сохранятся стили первого кадра
  - `both` - до начала применятся стили первого кадра, после конца - стили последнего

> `animation` - короткий способ записи, при этом свойства могут идти в любом порядке (например: `animation: rotate 1s running alternate infinite both;`)

---
transition: none
---

<style scoped>
  div {
    --slidev-code-font-size: 10px;
    --slidev-code-line-height: 12px;
  }
</style>

# БЭМ

> **БЭМ** (Блок — Элемент — Модификатор) — методология для структурирования и организации кода интерфейсов, созданная в «Яндексе».
Она помогает писать читаемый, переиспользуемый и масштабируемый код

<div class="grid grid-cols-2 gap-4">

<div>

- **Блок** — независимый компонент интерфейса<br/>
  Пример: `button`, `header`, `side-menu`

- **Элемент** — часть блока, не существует вне его<br/>
  Пример: `menu__item`, `button__icon`

- **Модификатор** — сущность, определяющая внешний вид, состояние и поведение блока или элемента<br/>
  Пример: `button--active`, `menu__item--selected`

</div>

```html
<!-- Блок "product-card" -->
<article class="product-card product-card--featured">
  <!-- Элемент: изображение товара -->
  <div class="product-card__image-wrapper">
    <img 
      src="images/phone.jpg" 
      alt="Смартфон XPhone 12" 
      class="product-card__image"
    >
  </div>

  <!-- Элемент: информация о товаре -->
  <div class="product-card__info">
    <h2 class="product-card__title">XPhone 12</h2>
    <p class="product-card__description">
      Мощный смартфон с дисплеем 6.1" и камерой 48 МП.
    </p>
    <span class="product-card__price">69 990 ₽</span>
  </div>

  <!-- Элемент: кнопка действия -->
  <button class="product-card__button button button--primary">
    В корзину
  </button>
</article>
```

</div>

---
transition: none
---

# БЭМ

Правила

- Наименование
  - Слова в названиях разделяются `-`
  - Имя элемента отделяется от имени блока двумя подчеркиваниями (`__`).
  - Имя модификатора отделяется от имени блока или элемента одним подчеркиванием (`_`)
  - Значение модификатора отделяется от имени модификатора одним подчеркиванием (`_`)
- Селекторы CSS должны использовать только названия классов
- Селекторы желательно не комбинировать (`.button.button_theme_dark` - плохо)
- Элементы не могут существовать вне блоков

<br />

> Это - только основные из правил БЭМ. Об остальных можете прочесть в документации

---

# БЭМ

Критика

- **Длинные имена классов и избыточность** — из-за длины названий классов и повторяющихся префиксов код становится громоздким
- **Сложность наследования модификаторов** - модификаторы не могут существовать сами по себе, поэтому их часто приходится дублировать для разных блоков или элементов
- **Много ручной работы**
- **Трудности с обучением и единообразием** - разные команды могут по-разному трактовать правила БЭМ

<br />

> Подробнее в статье "[БЭМ'а не должно существовать](https://habr.com/ru/articles/422537/?mobile=no)"

---
layout: cover
---

# Web API и асинхронность

---

# Web API

> **Web API** - набор инструментов или функциональных возможностей для взаимодействия JavaScript с браузером

### Из чего состоит

- **DOM API** — управление элементами страницы
- **Fetch / XMLHttpRequest API** - сетевые запросы
- **Storage API** - работа с локальными браузерными хранилищами данных
- **File API** - работа с файлами
- **Geolocation API** — получение координат пользователя.
- **Canvas и WebGL API** — 2D и 3D-графика
- **Audio и Video API** — контроль и манупуляции с мультимедиа (аудио и видео)
- **WebRTC API** - захват и передача аудио и видео
- и другие

---
src: ./_shared.md#2
transition: none
---

---

<style scoped>
  p, li {
    font-size: 14px;
    line-height: 1.3rem;
  }

  blockquote {
    margin: 8px 0;
  }
</style>

# Асинхронность

> JavaScript в браузере - однопоточный (то есть программа исполняет все инструкции по очереди и по дной за раз, без возможности выполнять несколько вычислений одновременно), поэтому долгие синхронные операции будут блокировать любые другие, в том числе заблокируют пользовательский интерфейс

> **Поток (Thread)** - это набор инструкций, которым следует программа, или наименьшая единица выполнения программы внутри процесса

Асинхронность позволяет избежать блокировки основного (и единственного) потока при запуске долгих задач

Большинство функций, предоставляемых браузером, асинхронные - то есть они выполняются **не в основном потока** вашей программы, а самим **браузером в отдельном потоке**

### Примеры асинхронных функций
- `setTimeout` - позволяет вызывать функцию спустя заданное время
- `setInterval` - позволяет регулярно вызывать функцию раз в заданное время

> Обе функции возвращают число-идентификатор. Его можно передать в `clearTimeout/clearInterval` соответственно, чтобы отменить запуск функции

- `fetch` - отправка сетевого запроса


---

# Асинхронность

Коллбэки (callbacks)

Для работы с асинхронными функциями (в том числе для получения результата их работы) есть несколько подходов, один из них - **коллбэк (callback, функция обратного вызова)**

```js {monaco-run} {autorun:false}
console.log('Начало работы программы');

// В синхронном варианте мы бы запустили бесконечный цикл, 
// в котором проверяли, что прошло 1000 миллисекунд
setTimeout(() => {
  console.log('Асинхронная операция');
}, 1000);

console.log('Конец работы программы');
```

---

# Асинхронность

Ад коллбэков (Callback hell)

```js {*}{maxHeight:'400px'}
function getUser(id, callback) { 
  setTimeout(() => {
    callback({ id: id, name: 'Иван' });
  }, 500);
}

function getOrders(userId, callback) {
  setTimeout(() => {
    callback([{ id: 101, item: 'Телефон' }]);
  }, 500);
}

function getOrderDetails(orderId, callback) {
  setTimeout(() => {
    callback({ id: orderId, shippingId: 555 });
  }, 500);
}

function getShippingInfo(shippingId, callback) {
  setTimeout(() => {
    callback({ id: shippingId, status: 'В пути' });
  }, 500);
}

getUser(1, function(user) {
  getOrders(user.id, function(orders) {
    getOrderDetails(orders[0].id, function(details) {
      getShippingInfo(details.shippingId, function(shipping) {
        console.log('Информация о доставке:', shipping);
      });
    });
  });
});
```


---
transition: none
---

# Асинхронность

Промисы

> **Промис (Promise)** - специальный объект, хранящий результат асинхронной операции и имеющий одно из состояний:
> - `pending` - ожидание результата
> - `fulfilled` - успешное выполнение
> - `rejected` - ошибка выполнения

<img src="https://learn.javascript.ru/article/promise-basics/promise-resolve-reject.svg" class="mt-4 mx-auto" />

---

<style scoped>
  p:not(h1 + p), li {
    font-size: 14px;
    line-height: 1.3rem;
  }

  blockquote {
    margin: 8px 0;
  }
</style>

# Асинхронность

Промисы

Промис создаётся при помощи конструкции `new Promise((resolve, reject) => {})` и принимает коллбэк, который сразу будет вызван. В коллбэк будут переданы 2 параметра:
- Функция `resolve(value)` - её вызов переведёт промис в статус `fullfilled` и назначит `value` результатом
- Функция `reject(value)` - её вызов переведёт промис в статус `rejected` и назначит `value` результатом (ошибкой)

Для обработки результата промиса используются методы `then`, `catch` и `finally`:
- `.then((onfulfilled, onrejected) => {})`
  - `onfulfilled` - коллбэк, который вызовется при успешном выполнении
  - `onrejected` - коллбэк, который вызовется при ошибке
- `.catch((onrejected) => {})` - обработчик ошибок, аналог передачи коллбэка `onrejected` в `.then`, но может обработь любую ошибку из **цепочки промисов**
- `.finally((onfinally) => {})` - обаботчик, который выполнится вне зависимости от результата промиса

> **Важно:** промисы могут возвращать другие промисы - это называется цепочкой промисов. В таком случае используется несколько `.then`, а `.catch` обработает всю предыдущую часть цепочки

---

# Асинхронность

Цепочка промисов

```js {*}{maxHeight:'400px'}
function getUser(id) {
  return new Promise((resolve) => {
    setTimeout(() => {
      resolve({ id: id, name: 'Иван' });
    }, 500);
  });
}

function getOrders(userId) {
  return new Promise((resolve) => {
    setTimeout(() => {
      resolve([{ id: 101, item: 'Телефон' }]);
    }, 500);
  });
}

function getOrderDetails(orderId) {
  return new Promise((resolve) => {
    setTimeout(() => {
      resolve({ id: orderId, shippingId: 555 });
    }, 500);
  });
}

function getShippingInfo(shippingId) {
  return new Promise((resolve) => {
    setTimeout(() => {
      resolve({ id: shippingId, status: 'В пути' });
    }, 500);
  });
}

getUser(1)
  .then(user => getOrders(user.id))
  .then(orders => getOrderDetails(orders[0].id))
  // Обработает только 2 верхних промиса
  .catch(error => console.log(''))
  .then(details => getShippingInfo(details.shippingId))
  .then(shipping => console.log('Информация о доставке:', shipping))
  .catch(error => console.error('Ошибка:', error));
  .finally(() => console.log('Работа завершена'))
```

---
transition: none
---

<style scoped>
  p:not(h1 + p) {
    font-size: 12px;
    line-height: 1.1rem;
    margin: 6px 0;
  }

  div {
    --slidev-code-font-size: 10px;
    --slidev-code-line-height: 12px;
  }
</style>

# Асинхронность

Методы промисов

<div class="grid grid-cols-2 gap-2">

<div class="bg-gray-200 dark:bg-gray-800 p-2 border-rd-4">

### `Promise.all([...])`

Принимает массив промисов и возвращает один новый, результат которого будет массивом из результатов всех переданных промисов

```js
Promise.all([
  new Promise(resolve => setTimeout(() => resolve(1), 3000)),
  new Promise(resolve => setTimeout(() => resolve(2), 2000)),
  new Promise(resolve => setTimeout(() => resolve(3), 1000))
])
  .then(console.log) // [1, 2, 3]
```

Если любой из промисов переходит в статус `rejected`, то итоговый промис сразу же завершается с ошибкой

```js
Promise.all([
  new Promise(resolve => setTimeout(() => resolve(1), 3000)),
  new Promise((_, reject) => setTimeout(() => reject(2), 2000)),
  new Promise(resolve => setTimeout(() => resolve(3), 1000))
])
  .then(console.log) // Error: Uncaught (in promise) 2
```

</div>

<div class="bg-gray-200 dark:bg-gray-800 p-2 border-rd-4">

### `Promise.allSettled([...])`

Принимает массив промисов, дожидается выполнения всех и возвращает массив с объектами:
```js
[ { status: 'fulfilled': value: /* результат */ }, 
  { status: 'rejected': reason: /* ошибка */ } ]
```

```js
Promise.allSettled([
  new Promise(resolve => setTimeout(() => resolve(1), 3000)),
  new Promise((_, reject) => setTimeout(() => reject(2), 2000)),
  new Promise(resolve => setTimeout(() => resolve(3), 1000))
])
  .then(console.log) 
  // [{"status":"fulfilled","value":1},
  // {"status":"rejected","reason":2},
  // {"status":"fulfilled","value":3}]
```

</div>

</div>

---
transition: none
---

<style scoped>
  p:not(h1 + p) {
    font-size: 12px;
    line-height: 1.1rem;
    margin: 6px 0;
  }

  div {
    --slidev-code-font-size: 10px;
    --slidev-code-line-height: 12px;
  }
</style>

# Асинхронность

Методы промисов

<div class="grid grid-cols-2 gap-2">

<div class="bg-gray-200 dark:bg-gray-800 p-2 border-rd-4">

### `Promise.race([...])`

Принимает массив промисов и возвращает промис с результатом/ошибкой первого выполненного промиса

```js
Promise.race([
  new Promise(resolve => setTimeout(() => resolve(1), 3000)),
  new Promise(resolve => setTimeout(() => resolve(2), 2000)),
  new Promise(resolve => setTimeout(() => resolve(3), 1000))
])
  .then(console.log) // 3
```

</div>

<div class="bg-gray-200 dark:bg-gray-800 p-2 border-rd-4">

### `Promise.any([...])`

Принимает массив промисов и возвращает результат первого успешного промиса
```js
[ { status: 'fulfilled': value: /* результат */ }, 
  { status: 'rejected': reason: /* ошибка */ } ]
```

```js
Promise.any([
  new Promise(resolve => setTimeout(() => resolve(1), 3000)),
  new Promise((_, reject) => setTimeout(() => reject(2), 2000)),
  new Promise((_, reject) => setTimeout(() => reject(3), 1000))
])
  .then(console.log) // 
```

Если ни один промис не был успешен, то вернёт ошибку

```js
Promise.any([
  new Promise((_, reject) => setTimeout(() => reject(1), 3000)),
  new Promise((_, reject) => setTimeout(() => reject(2), 2000)),
  new Promise((_, reject) => setTimeout(() => reject(3), 1000))
])
  .then(console.log) // AggregateError: All promises were rejected
```

</div>

</div>

---

# Асинхронность

Методы промисов

<div class="bg-gray-200 dark:bg-gray-800 p-2 border-rd-4">

### `Promise.resolve(value)` / `Promise.reject(error)`

Создают успешный/неуспешный промис. В современной раработке почти не используются

Нужны в тех случаях, когда ожидается, что функция вернёт именно промис

```js
const usersCache = new Map();

function getUser(id) {
  if (usersCache.has(id)) {
    return Promise.resolve(usersCache.get(id))
  }

  // Имитация запроса пользователя с сервера
  return new Promise((resolve) => {
    setTimeout(() => {
      resolve({ id, name: 'Иван' });
    }, 1000);
  });
}

```

</div>

---
transition: none
---

<style scoped>
  div {
    --slidev-code-font-size: 9px;
    --slidev-code-line-height: 11px;
  }
</style>

# Асинхронность

`async`/`await`

Самый простой и современный способ работать с промисами - использовать ключевые слова `async` и `await`

<div class="grid grid-cols-2 gap-2">

```js
// Имитация запроса с сервера
function requestUser(id) {
  return new Promise((resolve) => {
    setTimeout(() => {
      resolve({ id, name: 'Иван' });
    }, 1000);
  });
}

function printUserInfo(id) {
  requestUser(id)
    .then(user => {
      console.log(user.name);
      return true;
    })
    .catch(err => {
      console.log(`Ошибка: ${err}`);
      return false;
    })
}

printUserInfo(1)
  .then(console.log)
```

```js
// Имитация запроса с сервера
async function requestUser(id) {
  return new Promise((resolve) => {
    setTimeout(() => {
      resolve({ id, name: 'Иван' });
    }, 1000);
  });
}

async function printUserInfo(id) {
  try {
    const user = await requestUser(id)
    console.log(user.name)
    return true;
  } catch (err) {
    console.log(`Ошибка: ${err}`)
    return false;
  }
}

const result = printUserInfo(1)
console.log(result)
```

</div>

---

# Асинхронность

`async`/`await`

- Ключевым словом `async` помечается функция, которая возвращает `Promise`. Притом она будет неявно возвращать промис всегда, даже если в функции отсутствует `return`
- Ключевое слово `await` используется для ожидания результата промиса

> `await` можно использовать **только** внутри асинхронной (`async`) функции, либо на самом верхнем уровне программы

- Для обработки ошибок можно использовать блок `try {} catch (err) {}` вместо метода `.catch`, как будто работа ведётся с обычным синхронным кодом

---

<style scoped>
  li {
    font-size: 12px;
    line-height: 1.1rem;
  }
</style>

# Практика

1. Напишите функцию, которая печатает числа в заданном диапазоне с заданной задержкой
  ```js
  function printNumbersIntervalDelayed(from, to, delay = 500) {}

  printNumbersIntervalDelayed(1, 3, 1000)
  // 1 <ждём секунду> 2 <ждём секунду> 3
  ```
2. Напишите функцию, принимающую массив асинхронных функций и коллбэк, который запускается с **упорядоченными результатами** при завершении всех функций. **Промисы запрещены!**
  ```js
    function asyncFunc1(callback) {
      setTimeout(() => callback(1), 3000);
    }
    
    function asyncFunc2(callback) {
      setTimeout(() => callback(2), 2000);
    }
    
    function asyncFunc3(callback) {
      setTimeout(() => callback(3), 1000);
    }
    
    asyncParallel([asyncFunc1, asyncFunc2, asyncFunc3], console.log);
  ```
3. Напишите приложение-секундомер с возможностью паузы и сброса таймера

---
src: ./_shared.md#1
---

---

# Дополнительные материалы

- [Doka - CSS-анимации](https://doka.guide/css/animation/)
- [Методология БЭМ](https://ru.bem.info/methodology/)
- [learn.javascript.ru - Асинхронность](https://learn.javascript.ru/async)