---
theme: default
title: "Основы PostgreSQL. Дравйверы и ORM / Курс по веб-разработке, 11 класс"
class: text-center
drawings:
  persist: false
transition: slide-left
mdc: true
fonts:
  sans: Montserrat
hideInToc: true
browserExporter: true
---

# Курс по веб-разработке

<h2 class="color-gray-400 fw-200">Основы PostgreSQL: возможности, схемы, <code>EXPLAIN ANALYZE</code>, роли и права<br/>Дравйверы и ORM</h2>

---

<style scoped>
  li {
    margin-bottom: 4px;
    font-size: 14px;
    line-height: 1.3rem;
  }

  h3 {
    font-size: 20px;
    margin-bottom: 4px;
    font-weight: 700;
  }
</style>

# PostgreSQL

> **PostgreSQL (Postgres)** - мощная объектно-реляционная СУБД с открытым исходным кодом, на текущий момент являющаяся промешленным стандартом

### Особенности

- **Открытый исходный код**
- **Надёжность и согласованность данных** - механизм журналирования (логирования) и восстановления данных, что гарантирует минимальные потери; гибкая настройка изоляции транзакций (об этом, возможно, позже)
- **Множество встроенных возможностей** - большой набор типов данных (денежные единицы, геоданные, JSON, XML и т.д.); полнотекстовый поиск; поддержка B+\-деревьев, Hash, GIN и GiST, BRIN для индексов
- **Полное соответствие стандартам SQL**
- **Объектно-реляционная модель** - поддержка одновременно классического ряляционного подхода и объектной модели: пользовательские и составные типы, наследование таблиц, сложные типы данных (например, массивы и объекты)
- **Гибридность** - хорошая поддержка JSON и JSONB позволяет использовать postgres как NoSQL БД
- **Гибкая система прав** - наличие ролей и пользователей с контролем доступа для объектов БД и конкретных строк таблиц (RLS, row-level security)
- **Расширяемость** - позвоялет писать пользовательские типы, функции, индексы и операторы на обширном количестве языков (C, C++, Python, JS, Java, Lua и пр.) или использовать готовые расширения

---

<style scoped>
  li {
    margin-bottom: 4px;
    font-size: 14px;
    line-height: 1.3rem;
  }

  h3 {
    font-size: 20px;
    margin-bottom: 4px;
    font-weight: 700;
  }

  div {
    --slidev-code-font-size: 8px;
    --slidev-code-line-height: 10px;
  }
</style>


# PostreSQL

Схемы

> Все объекты БД (таблицы, представления, функции и т.п.) postgres принадлежат каким-то **схемам** - логическим контейнерам для разделения. По умолчанию обычно создаётся схема `public`. По сути, является аналогом **пространства имён (namespace)** в программировании

<div class="grid grid-cols-2 gap-2 mt-4">

<div>

### Пример структуры

```
 ├── Схема: public
 │    ├── Таблица: users
 │    └── Таблица: orders
 └── Схема: analytics
      ├── Таблица: user_stats
      └── Представление: active_users
```

### Пример

```sql  
CREATE SCHEMA analytics;
CREATE TABLE analytics.user_stats (...);

-- search_path - параметр конфигурации, определяющий в каких схемах postgres
-- будет осуществлять поиск при обращении по имени (без явного указания схемы)
SET search_path TO analytics, public;
SHOW search_path;
```

</div>

<div>

### Назначение

- Разделение логики по областям ответственности, например: core (всё, что нужно для работы приложения) и analytics (всё, что связано с аналитикой)
- Совместная работа нескольких команд без конфликтов имён
- Изоляция данных по клиентам (multi-tenant архитектура) - например, для разных организаций можно предоставлять разные данные
- Управление доступом к объектам на уровне схем

</div>

</div>

---

<style scoped>
  li {
    margin-bottom: 2px;
    font-size: 11px;
    line-height: 1rem;
  }

  blockquote {
    margin-bottom: 4px;
  }

  h3 {
    font-size: 20px;
    margin-bottom: 4px;
    font-weight: 700;
  }

  div {
    --slidev-code-font-size: 8px;
    --slidev-code-line-height: 10px;
  }
</style>

# PostgreSQL

Роли и права

> В postgres используется ролевая система прав. Роль - обобщённое понятие, полдразумевающая конкретного пользователя или группу пользователей, которые используют базу данных

<div class="grid grid-cols-2 gap-2">

<div>

- Роли имеют набор прав к конкретным объектам БД
- Роли имеют набор свойств (атрибутов), определяющих то, что может делать пользователь этой роли, например: 
  - `LOGIN` - роль становится пользователем, разрешается подключение к БД
  - `SUPERUSER` - полные права без ограничений
  - `CREATEDB` - разрешается создание БД
  - `CREATEROLE` - разрешается изменение других ролей
  - `INHERIT` - наследует ли роль права ролей, в которые входит
  - `PASSWORD` - пароль
  - и другие
- Роли имеют иерархическую структуру, то есть могут наследоваться друг от друга. При этом наследуются только права, но не атрибуты

</div>

```sql
-- Создание группы
CREATE ROLE analysts;

-- Создание пользователя
CREATE ROLE shadi LOGIN PASSWORD 'secret';
-- Или
CREATE USER shadi PASSOWRD 'secret';

-- Назначаем shadi членом группы analysts
GRANT analysts TO shadi;

-- Разрешение операторов для роли analysts
GRANT SELECT, INSERT ON employees TO analysts;

-- Отзыв прав
REVOKE INSERT ON employees FROM analysts;
```

</div>

### Советы

- В реальных приложениях не стоит использовать атрибут `SUPERUSER`
- Для приложения, аналитики и администрирования БД стоит создавать отдельные роли
- Для бизнес-логики приложения можно использовать RLS (row-lever security) - правила доступа на уровне строк таблиц

---

<style scoped>
  li {
    margin-bottom: 2px;
    font-size: 11px;
    line-height: 1rem;
  }

  blockquote {
    margin-bottom: 4px;
  }

  h3 {
    font-size: 20px;
    margin-bottom: 4px;
    font-weight: 700;
  }

  div {
    --slidev-code-font-size: 9px;
    --slidev-code-line-height: 10px;
  }
</style>

# PostgreSQL

Основы `EXPLAIN ANALYZE`

> `EXPLAIN ANALYZE` - специальная команда postgres, показывающая реальный план выполнения запроса. Позволяет оценить производительность и время запроса и найти проблемные места

### Элементы вывода

- **Seq Scan / Index Scan / Bitmap Heap Scan** — способ чтения данных
- **Actual time** — реальное время выполнения шага
- **Rows** — количество обработанных строк
- **Loops** — сколько раз шаг выполнялся
- **Cost** — оценка планировщика (startup_cost..total_cost)
- **Buffers** — (если включено) использование памяти и I/O

### Пример вывода

```
dvdrental=> explain analyze select * from rental where inventory_id in (1, 2, 3);
                                                          QUERY PLAN                                                           
 -------------------------------------------------------------------------------------------------------------------------------
 Bitmap Heap Scan on rental  (cost=12.95..50.93 rows=12 width=36) (actual time=0.072..0.163 rows=10 loops=1)
   Recheck Cond: (inventory_id = ANY ('{1,2,3}'::integer[]))
   Heap Blocks: exact=10
   ->  Bitmap Index Scan on idx_fk_inventory_id  (cost=0.00..12.95 rows=12 width=0) (actual time=0.042..0.043 rows=10 loops=1)
         Index Cond: (inventory_id = ANY ('{1,2,3}'::integer[]))
 Planning Time: 2.011 ms
 Execution Time: 0.248 ms
(7 rows)
```

---

<style scoped>
  li, p {
    margin-bottom: 2px;
    font-size: 11px;
    line-height: 1rem;
  }

  blockquote {
    margin-bottom: 4px;
  }

  h3 {
    font-size: 14px;
    line-height: 1.3rem;
    margin-bottom: 4px;
    font-weight: 700;
  }

  div {
    --slidev-code-font-size: 7px;
    --slidev-code-line-height: 9px;
  }
</style>

# Драйверы

> **Драйвер (Driver)** - это специальная программа, которая обеспечивает связь между приложением и внешней системой или устройством, переводя запросы приложения в понятный для этой системы формат. В контексте БД - это библиотека, которая позволяет приложению отправлять SQL-запросы и получать результаты от конкретной СУБД (PostgreSQL, MySQL, SQLite и т.д.)

### Примеры драйверов для Python

- `psycopg2` - для PostgreSQL
- `mysql-connector-python` - драйвер MySQL
- `sqlite3` - для SQLite (встроенный)

### Пример работы

```py
import psycopg2

# Подключение к базе данных
conn = psycopg2.connect(
    dbname="mydb",
    user="postgres",
    password="secret",
    host="localhost",
    port=5432
)

# Создаём курсор - объект для выполнения запросов
cur = conn.cursor()

# Выполняем запрос
cur.execute("SELECT id, name FROM users WHERE active = TRUE;")

# Получаем и печатаем результаты
rows = cur.fetchall()
for row in rows:
    print(row)

# Закрываем соединение
cur.close()
conn.close()
```

---

<style scoped>
  h3 {
    font-size: 20px;
    font-weight: 700;
    margin: 8px 0;
    line-height: 1.4rem;
  }

  li {
    font-size: 12px;
    line-height: 1.1rem;
  }
</style>

# ORM

Введение

> **ORM (Object-Relational Mapping)** — это технология программирования, позволяющая работать с базой данных при помощи **объектов языка программирования**, а не через SQL-запросы напрямую, то есть альтернатива использования **драйверов**

### Преимущества

- Повышает читаемость и удобство
- Практически полностью избавляет от необходимости писать SQL (в особых случаях это всё ещё может требоваться для оптимизации)
- Инкапсулирует (скрывает) от разработчика взаимодействие с СУБД, то есть позволяет не думать о том, какая именно СУБД используется. Вдобавок её в любой момент можно поменять на другую без необходимости переписывания запросов
- Обеспечивает безопаность (защищает от SQL-инъекций)
- Упрощает построение связей между таблицами
- Поддерживает инструменты для миграции

### ORM для Python
- **SQLAlchemy** - классический вариант, мощный и гибкий, поддерживает SQL и ORM-уровень
- **Django ORM** - встроенный ORM в Django, простой для веб-приложений
- **Peewee** - лёгкий и простой ORM, подходит для небольших проектов
- **Tortoise ORM** - асинхронный ORM для async Python (например, с FastAPI)
- **Pony ORM** - позволяет писать запросы в виде генераторов Python, автоматически строит SQL
- **Ormantic** - async ORM для FastAPI, основан на SQLAlchemy core
- **Gino** - асинхронный ORM для PostgreSQL, использует SQLAlchemy core

---

# ORM

SQLAlchemy

<div class='canvas'>
<svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 800 275" xmlns:bx="https://boxy-svg.com">
  <g transform="matrix(2.759496, 0, 0, 2.759496, -826.266773, -911.541613)" style="">
    <rect x="300.145" y="364.816" width="40.927" height="32.741" rx="10" fill="#e6f2ff" stroke="#cfe6ff" style="stroke-width: 1.44954px;"/>
    <text style="fill: rgb(11, 59, 115); font-size: 5px; font-weight: 600; stroke-width: 1.44954px; text-anchor: middle; white-space: pre;" x="320.791" y="382.259">Приложение</text>
  </g>
  <rect x="178.201" y="1.171" width="301.162" height="272.504" rx="10" stroke-width="1.5" style="stroke-width: 1.5; fill: rgb(255, 255, 255);" stroke="#cbd5e1"/>
  <text style="fill: rgb(30, 41, 59); font-size: 13.8px; font-weight: 700; text-anchor: middle; white-space: pre;" x="336.293" y="23.76">ORM (SQLAlchemy)</text>
  <rect x="185.706" y="38.818" width="139.346" height="82.822" rx="8" fill="#f1f5f9" stroke="#e2e8f0" style="stroke-width: 4px;"/>
  <text style="fill: rgb(15, 23, 42); font-size: 13.8px; font-weight: 600; text-anchor: middle; white-space: pre;" x="259.447" y="71.433">Модели</text>
  <text style="fill: rgb(51, 65, 85); font-size: 4px; text-anchor: middle; white-space: pre;" x="390.92" y="391.837" transform="matrix(2.759496, 0, 0, 2.759496, -821.83379, -994.301072)">Классы, описывающие <tspan x="390.9200134277344" dy="1em">​</tspan>сущности БД</text>
  <rect x="331.687" y="37.499" width="138.414" height="82.822" rx="8" stroke="#e2e8f0" style="fill: rgb(241, 245, 249); stroke-width: 4px;"/>
  <text style="fill: rgb(15, 23, 42); font-size: 13.8px; font-weight: 600; text-anchor: middle; white-space: pre;" x="401.28" y="61.948">Session</text>
  <text style="fill: rgb(51, 65, 85); font-size: 11.1px; text-anchor: middle; white-space: pre;" x="400.353" y="91.382" transform="matrix(1, 0, 0, 1, -0.497355, -12.123829)">Сессия - единица <tspan x="400.3529968261719" dy="1em">​</tspan>работы <tspan x="400.3529968261719" dy="1em">​</tspan>(или буфер изменений)</text>
  <g transform="matrix(2.759496, 0, 0, 2.759496, -1084.475204, -844.888599)" style="">
    <rect x="491.165" y="364.816" width="40.927" height="32.741" rx="10" fill="#fff7ed" stroke="#fde3b7" stroke-width="1.2" style="stroke-width: 1.2;"/>
    <text style="fill: rgb(122, 62, 0); font-size: 5px; font-weight: 700; text-anchor: middle; white-space: pre;" x="511.625" y="375.73">Engine / Core</text>
    <text style="fill: rgb(122, 62, 0); font-size: 4px; text-anchor: middle; white-space: pre;" x="511.625" y="382.551">Генерация SQL</text>
    <text style="fill: rgb(122, 62, 0); font-size: 4px; text-anchor: middle; white-space: pre;" x="511.625" y="388.008">Соединения с БД</text>
  </g>
  <g transform="matrix(2.759496, 0, 0, 2.759496, -549.849052, -1088.141708)" style="">
    <rect x="390.215" y="430.299" width="98.223" height="32.741" rx="12" fill="#f0fff4" stroke="#d2f7dd" style="stroke-width: 1.44954px;"/>
    <ellipse cx="439.325" cy="441.212" rx="21.828" ry="8.185" fill="#e6fff0" stroke="#bfeed1" style="stroke-width: 1.44954px;"/>
    <ellipse cx="439.325" cy="435.756" rx="21.828" ry="8.185" style="stroke: rgb(191, 238, 209); fill: rgb(230, 255, 240); stroke-width: 1.44954px;"/>
    <text style="fill: rgb(11, 90, 31); font-size: 5px; font-weight: 700; stroke-width: 1.44954px; text-anchor: middle; white-space: pre;" x="439.52" y="437.871">База данных</text>
    <text style="fill: rgb(11, 90, 31); font-size: 5px; stroke-width: 1.44954px; text-anchor: middle; white-space: pre;" x="440.184" y="457.091">(Postgres / MySQL / SQLite)</text>
  </g>
  <path style="fill: rgb(216, 216, 216); stroke-width: 2px; stroke: rgb(0, 122, 255);" d="M 384.021 211.485 L 519.706 158.189 L 525.222 156.023"/>
  <text style="fill: rgb(119, 119, 119); font-family: Arial, sans-serif; font-size: 9.99999px; line-height: 6.39999px; white-space: pre; transform-box: fill-box; transform-origin: 77.0353px 15.5458px;" transform="matrix(0.927185, -0.374608, 0.374605, 0.927185, -30.77215, 2.4769)" x="416.948" y="167.323">Сгенерированный SQL-запрос</text>
  <path d="M 245.911 44.101 L 251.911 56.101 L 239.911 56.101 L 245.911 44.101 Z" bx:shape="triangle 239.911 44.101 12 12 0.5 0 1@a0364518" style="stroke: rgb(0, 0, 0); fill: rgb(0, 122, 255); stroke-width: 0px; transform-box: fill-box; transform-origin: 50% 50%;" transform="matrix(0.374605, 0.927185, -0.927183, 0.374608, 276.136193, 106.477993)"/>
  <path style="fill: rgb(216, 216, 216); stroke-width: 2; stroke: rgb(18, 221, 79);" d="M 386.892 227.767 L 527.779 171.559"/>
  <text style="fill: rgb(119, 119, 119); font-family: Arial, sans-serif; font-size: 9.99999px; line-height: 6.39999px; white-space: pre; transform-origin: 493.983px 173.848px;" transform="matrix(0.933581, -0.358369, 0.358367, 0.933581, 8.092406, 29.72505)" x="416.948" y="167.323">Результат запроса</text>
  <path d="M 247.642 45.939 L 253.684 58.439 L 241.6 58.439 L 247.642 45.939 Z" bx:shape="triangle 241.6 45.939 12.084 12.5 0.5 0 1@ec87afda" style="stroke: rgb(0, 0, 0); fill: rgb(18, 221, 79); stroke-width: 0px; transform-origin: 247.641px 52.188px;" transform="matrix(-0.390207, -0.920727, 0.933686, -0.35963, 143.605655, 173.801937)"/>
  <text style="fill: rgb(119, 119, 119); font-family: Arial, sans-serif; font-size: 9.99999px; line-height: 6.39999px; white-space: pre; transform-origin: 493.983px 173.775px;" transform="matrix(0.766046, -0.642791, 0.642786, 0.766046, -307.369625, -93.514502)" x="416.948" y="167.323">Метод модели</text>
  <path d="M 245.911 44.101 L 251.911 56.101 L 239.911 56.101 L 245.911 44.101 Z" bx:shape="triangle 239.911 44.101 12 12 0.5 0 1@a0364518" style="stroke: rgb(0, 0, 0); fill: rgb(0, 122, 255); stroke-width: 0; transform-origin: 245.911px 50.101px;" transform="matrix(0.544637, 0.838672, -0.83867, 0.544641, -64.154289, 37.433365)"/>
  <path style="fill: rgb(216, 216, 216); stroke: rgb(0, 122, 255); stroke-width: 2px;" d="M 116.855 141.154 L 185.155 85.137"/>
  <path style="fill: rgb(216, 216, 216); stroke-width: 2; stroke: rgb(18, 221, 79);" d="M 118.086 157.657 L 186.893 100.144"/>
  <path d="M 247.642 45.939 L 253.684 58.439 L 241.6 58.439 L 247.642 45.939 Z" bx:shape="triangle 241.6 45.939 12.084 12.5 0.5 0 1@ec87afda" style="stroke: rgb(0, 0, 0); fill: rgb(18, 221, 79); stroke-width: 0; transform-origin: 247.641px 52.188px;" transform="matrix(-0.694625, -0.719372, 0.742439, -0.670736, -127.490257, 103.862559)"/>
  <text style="fill: rgb(119, 119, 119); font-family: Arial, sans-serif; font-size: 7.99997px; line-height: 6.39999px; white-space: pre; transform-origin: 493.983px 173.775px;" transform="matrix(0.766046, -0.642791, 0.642786, 0.766046, -307.10815, -46.650317)" x="416.948" y="167.323">Объект с данными</text>
  <path style="fill: rgb(216, 216, 216); stroke-width: 2; stroke: rgb(0, 122, 255);" d="M 336.992 160.111 L 417.95 122.417"/>
  <text style="fill: rgb(119, 119, 119); font-family: Arial, sans-serif; font-size: 7.99999px; line-height: 6.39999px; white-space: pre; transform-origin: 493.983px 173.733px;" transform="matrix(0.906309, -0.42262, 0.422617, 0.906309, -52.141254, -40.674442)" x="416.948" y="167.323">execute() / flush()</text>
  <path d="M 245.911 44.101 L 251.911 56.101 L 239.911 56.101 L 245.911 44.101 Z" bx:shape="triangle 239.911 44.101 12 12 0.5 0 1@a0364518" style="stroke: rgb(0, 0, 0); fill: rgb(0, 122, 255); stroke-width: 0; transform-origin: 245.911px 50.101px;" transform="matrix(-0.422616, -0.906309, 0.906307, -0.42262, 92.311201, 109.516053)"/>
  <path style="fill: rgb(216, 216, 216); stroke-width: 2; stroke: rgb(18, 221, 79);" d="M 303.402 160.336 L 381.012 125.696"/>
  <text style="fill: rgb(119, 119, 119); font-family: Arial, sans-serif; font-size: 7.99999px; line-height: 6.39999px; white-space: pre; transform-origin: 493.983px 173.848px;" transform="matrix(0.913546, -0.406738, 0.406736, 0.913546, -127.5389, -43.000419)" x="416.948" y="167.323">Результат запроса</text>
  <path d="M 247.642 45.939 L 253.684 58.439 L 241.6 58.439 L 247.642 45.939 Z" bx:shape="triangle 241.6 45.939 12.084 12.5 0.5 0 1@ec87afda" style="stroke: rgb(0, 0, 0); fill: rgb(18, 221, 79); stroke-width: 0; transform-origin: 247.641px 52.188px;" transform="matrix(0.49996, 0.866048, -0.882652, 0.471199, 136.009812, 70.911807)"/>
</svg>

</div>

---

<style scoped>
  div {
    --slidev-code-font-size: 8px;
    --slidev-code-line-height: 10px;
  }
</style>

# ORM

SQLAlchemy

```py
from sqlalchemy import create_engine
from sqlalchemy.orm import declarative_base, sessionmaker, Mapped, mapped_column
from datetime import datetime

Base = declarative_base()

# Класс-модель
class User(Base):
  __tablename__ = "users"
  id: Mapped[int] = mapped_column(primary_key=True)
  name: Mapped[str]
  birth_date: Mapped[datetime] = mapped_column(default=datetime.utcnow)

# Создание engine - объекта, управляющего подключением к БД
engine = create_engine("sqlite:///example.db")

# Создание таблиц, связанных со всеми моделями
Base.metadata.create_all(engine)
Session = sessionmaker(bind=engine)

# Создание сессии. Сессия - объект, хранящий промежуточные изменения в памяти для последующего применения
session = Session()

# Добавление записи в сессию
session.add(User(name="Alice"))

# Фиксация изменений, пользователь создастся в БД
session.commit()
```

---

<style scoped>
  li, p {
    margin-top: 2px;
    margin-bottom: 2px;
    font-size: 11px;
    line-height: 1rem;
  }

  blockquote {
    margin-bottom: 4px;
  }

  h3 {
    font-size: 14px;
    line-height: 1.3rem;
    margin-bottom: 4px;
    font-weight: 700;
  }

  div {
    --slidev-code-font-size: 9px;
    --slidev-code-line-height: 10px;
  }
</style>

# Переменные окружения

> **Переменные окружения** - это внешние настройки системы или приложения (например, URL для подключения к БД или ключи внешних API), хранящие пары "ключ-значение". Позволяют вынести настройки из кода вовне

Переменные окружения обычно хранятся в файле `.env`, например:
```ini
DEBUG=True
DATABASE_URL=postgresql://user:pass@localhost:5432/app
API_KEY=some_api_key
```

### Зачем использовать

- **Безопасность** - все секреты хранятся только на локальной машине (ещё можно использовать специальные удалённые шифрованные хранилища для передачи)
- **Гибкость настройки приложения** - можно иметь несколько `.env` файлов с разными настройками
- **Простая интеграция** с различными инструментами: Docker, 

### Использование в Python

<div class="grid grid-cols-2 gap-2">

<div>

```py
import os

os.getenv("DATABASE_URL")
```

Установка перменной окружения перед запуском программы:
```sh
DATABASE_URL=some_url python main.py
```

</div>

```py
from dotenv import load_dotenv
import os

load_dotenv()  # Загрузка переменных из файла .env
db_url = os.getenv("DATABASE_URL")
```

</div>

<br />

> **Не забывайте добавлять файл `.env` в `.gitignore`!**

---

<style scoped>
  li {
    margin-bottom: 4px;
    font-size: 12px;
    line-height: 1.1rem;
  }

  h3 {
    font-size: 20px;
    margin-bottom: 4px;
    font-weight: 700;
  }
</style>

# Практика

### Подготовка

- Установите PostgreSQL и, если хотите, PgAdmin
- Создайте БД из [SQL файла](https://github.com/neondatabase-labs/postgres-sample-dbs/blob/main/chinook.sql)
  ```sh
  psql -U <username> -d <db_name> -f </path/to/script.sql>
  ```

### Задания

- **Представления (Views)**:
  - Все представления должны быть в отдельной схеме - `analytics`
  - Создайте представление `TopGenres`, содержащее жанры и количество треков в нём. Строки должны быть отсортированы по количеству треков
  - Создайте представление `ArtistRevenue`, содержащее информацию об артисте и сумму от продаж его треков
- **Рекурсивные запросы**:
  - Напишите запрос, формирующий иерархию сотрудников (начальник -> подчинённый)
- **Оконные функции**:
  - Для каждого жанра покажите среднюю цену трека и отклонение цены каждого трека от средней
  - Для каждого клиента покажите его ранг по общей сумме заказов среди всех клиентов
- **Роли и права**
  - Создайте роль `analytics` и любого пользователя с этой ролью. Эта роль должна мочь только просматривать представления из схемы `analytics`
  - Создайте роль `application` и любого пользователя с этой ролью. Эта роль не должна быть суперюзером и не должна мочь изменять другие роли

---

<style scoped>
  li {
    margin-bottom: 4px;
    font-size: 14px;
    line-height: 1.3rem;
  }
</style>

# Практика

Дополнительноек задание

Напишите **API** с использованием ORM:
- Создайте классы-модели всех таблиц (можно автоматизированно при помощи каких-либо инструментов)
- Опишите конфигурацию docker-compose, чтобы приложение и БД работали в контейнерах
- Опишите необходимые переменные окружения в `.env`
- Реализуйте следующие конечные точки:
  - `/api/tracks` - CRUD для сущности `Track`
  - `/api/analytics/top-genres` - отдаёт записи из представления `TopGenres`
  - `/api/analytics/artist-revenue/<artist-id>` - отдаёт суммарный заработок артиста с указанным id
  - `/api/analytics/top-albums` - отдаёт отсортированный по суммарной длине треков список альбомов (воспользуйтесь `join` в ORM)
  - `/genres-ranking` - отдаёт html с таблицей из представления `TopGenres`
  - `/employees-hierarchy` - отдаёт html с визуализацией дерева подчинённых (дерево можете построить как вам только вздумается)

---
src: ./_shared.md#1
---

---

# Дополнительные материалы

## PostgreSQL

- [PostgresPro - Учебные курсы](https://postgrespro.ru/education/courses)
- [Habr - Авторизация в PostgreSQL. Часть 1 — Роли и Привилегии](https://habr.com/ru/companies/timeweb/articles/661771/)
- [Selectel - Как оптимизировать PostgreSQL и не лишиться сна: разбор для разработчиков](https://selectel.ru/blog/postgresql-for-developers/)

## Python
- [Selectel - Как работать с PostgreSQL в Python](https://selectel.ru/blog/tutorials/postgresql-python/) - использование драйвера `psycopg2`
- [Skillfactory - Руководство по SQLAlchemy в Python](https://blog.skillfactory.ru/rukovodstvo-po-sqlalchemy-v-python/)