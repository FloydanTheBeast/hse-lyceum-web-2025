---
theme: default
title: Python - дополнительные главы / Курс по веб-разработке, 11 класс
class: text-center
drawings:
  persist: false
transition: slide-left
mdc: true
fonts:
  sans: Montserrat
hideInToc: true
browserExporter: true
---

# Курс по веб-разработке

<h2 class="color-gray-400 fw-200">Python - аннотации, модули, пакеты и асинхронное программирование</h2>

---
transition: none
---

<style scoped>
  p:not(h1 + p) {
    font-size: 12px;
    line-height: 1.1rem;
  }
</style>

# Python

Модули

<div class="flex flex-col gap-4">

> **Точка входа** - основной файл программы, который запускается при помощи интерпретатора. Для неё специальная переменная `__name__` будет равна `__main__`

> **Модуль** - файл с расширением `.py`, содержащий какую-то часть программы и импортируемый в главный файл или другой модуль. Каждый модуль определяет собственное **пространство имён** - место, где хранятся все переменные, по сути просто словарь со всеми переменными, функциями и классами, определёнными в файле модуля.

<div class="grid grid-cols-3 gap-2">

```py
# Импорт всего модуля 'module'
import module

module.<smth>
```

<div>

```py
# Импорт конкретных объявлений
from sys import path, version as ver
# Относительный (relative) импорт
from ..config import settings

print(path, ver)
```

<p>
<b>Абсолютные</b> импорты (без точки(ек) в начале) происходят относительно директории со входной точкой программы, <b>относительные</b> - относительно самого файла с импортом
</p>

</div>

<div>

```py
# Импорт всех объявлений
from sys import *

print(path, version, argv)
```

<p class="color-red-500" style="line-height: 1rem; margin-top: 4px">
Такой способ лучше не использовать, так как он может привести к множеству конфликтов
</p>

</div>

</div>

</div>

---
hideInToc: true
---

# Python

Модули

### Для чего нужны модули

- Организация программы (чтобы не писать весь код в одном файле)
- Переиспользования кода
- Позволяют избежать конфликтов имён
- Они делают код более читаемым и поддерживаемым

<h3 class="mt-4">Алгоритм поиска импортируемого модуля</h3>

- Поиск встроенного (built-in) модуля с указанным названием (все встроенные модули перечислены в `sys.builtin_module_names`)
- Поиск модуля в директориях, указанных в `sys.path`

---
hideInToc: true
---

# Python

Пакеты

> **Пакет** - директория, содержащая файл `__init__.py` (в нём находится код, который автоматически исполнится при первом импорте модуля из этого каталога. Может содержать импорты или код для инициализации, например подключение к базе данных) и **python-модули**. Нужны для составления **иерархии проекта**.

<div class="mt-4">

```
├── app.py                      Входная точка
├── controllers                 Пакет
│   ├── __init__.py
│   └── users_controller.py     Модуль
└── utils                       Пакет
    ├── __init__.py
    ├── fs.py                   Модуль
    └── images                  Пакет
        ├── __init__.py
        ├── croper.py           Модуль
        └── resizer.py          Модуль
```

</div>

<p class="font-size-4">
Для того, чтобы ограничить импортируемые из модуля/пакета имена при помощи <code >from <> import *</code>, в модуле или в файле <code>__init__.py</code> соответственно мы можем указать конкретный массив имён для импорта - <code>__all__ = ['имя1', 'имя2', ...]</code>
</p>

---
hideInToc: true
---

# Python

Работа с внешними зависимостями

<div class="mb-2">

> Для работы с внешними зависимостями (пакетами) в python есть собственный стандартный менеджер пакетов - `pip` (есть и другие, например `poetry` или `uv`)

</div>

> Список и версии установленных для проекта пакетов принято хранить в файле `requirements.txt`

<div class="font-size-3 grid grid-cols-2 gap-4">

<div>

Пример файла `requirements.txt`:

```
MarkupSafe==1.1.1
aiohttp==3.10.10
cryptography==43.0.3
Faker==24.7.1
Jinja2==3.1.4
numpy==2.1.3
pandas==2.2.3
pre_commit==4.0.1
psycopg==3.2.3
pylint==3.3.1
requests==2.32.3
```

</div>

<div>

Основные команды для работы с `pip`:

- `pip install <название_пакета>` - установка зависимостей
- `pip list` - вывод списка установленных зависимостей
- `pip freeze` - вывод списка установленных зависимостей в формате файла `requirements.txt`
- `pip freeze > requirements.txt` - сохранение списка установленных зависимостей в файле `requirements.txt`
- `pip install -r requirements.txt` - установка зависимостей, перечисленных в файле `requirements.txt`
- `pip uninstall <название>` - удаление зависимости

</div>

</div>

[PyPI - Python Package Index - Индекс пакетов Python](https://pypi.org/)

---
hideInToc: true
---

# Python

Виртуальные среды

> **Виртуальная среда (Virtual Environment)** - изолированный "проект", содержащий собственный набор зависимостей и локальный интерпретатор, необходимые для работы программы

Для работы с виртуальными окружениями можно использовать `venv` в стандартной библиотеке python. Команды для терминала:
- `python -m venv <название>` - создание виртуального окружения
- `<название>\\Scripts\\activate` (Win) или `source <название>/bin/activate` (MacOS/Linux) - активация окружения
- `deactivate` - деактивация окружения для использования глобального интерпретатора

Аналоги `venv`:
- `pipenv` - простой и мощный
- `poetry` - имеет поддержку виртуальных сред, но довольно сложен в использовании
- `pdm` - современный и быстрый инструмент

---

<style scoped>
  li {
    font-size: 15px;
    line-height: 1.5rem;
  }
</style>

# Python

Управление версиями интерпретатора

`pyenv` — инструмент для установки и переключения между несколькими версиями Python на одной машине (глобально, локально для проекта или на уровне сессии терминала)

### Зачем нужен?
- Удобное тестирование под разными версиями Python
- Иногда некотое пакеты работают только с конкретными версиями Python
- Работает вместе с `venv`, `virtualenv`, `poetry` и другими

### Основные команды

- `pyenv install --list` - список версий, доступных для установки
- `pyenv install 3.12.1` - установка конкретной версии
- `pyenv versions` - просмтр установленных версий
- `pyenv global 3.12.1` - установка глобальной версии
- `pyenv local 3.11.6` - установка локальной версии для конкретного проекта (для текущей директории и всех поддиректорий)
- `pyenv shell 3.10.13` - установка версии только для текущей сессии терминала
- `pyenv version` - текущая активная версия


---
transition: none
hideInToc: true
---

# Python

Аннотации типов (Type Hints)

> **Python** - язык с динамической типизацией, но при помощи аннотаций типов можно усилить типобезопасность. Они являются подсказками для статических анализаторов и разработчиков о том, с какими типами работает программа

```py
annotated_type: int = 5
```

Поддерживаются аннотации:

- Типов переменных
- Полей классов
- Аргументов и возвращаемых значений функций

Инструменты, поддерживающие аннотации:

- Различные IDE (PyCharm, VSCode и другие)
- Линтеры (pylint, mypy и другие)

---
transition: none
hideInToc: true
---

# Python

Аннотации типов

<<< @/../snippets/python/type-annotations.py {*}{maxHeight: '400px'}

---
hideInToc: true
---

# Python

Аннотации типов. Пользовательские и обобщённые (generics) типы

<<< @/../snippets/python/custom-type-annotations.py {*}{maxHeight: '400px'}

---
transition: none
---

# Python

Аннотации типов во время исполнения (runtime)

```py {*}{maxHeight: '400px'}
from typing import get_type_hints

# Аннотации текущего модуля
print(__annotations__)

def func(x: int, y: float) -> bool:
  pass

print(func.__annotations__)
# или
print(get_type_hints(func))

class Student:
  age: int | float
  grade: int

print(Student.__annotations__)
# Или
print(get_type_hints(Student))

# Работа с дженериками (интроспекция)

from typing import get_origin, get_args

# Базовый тип
print(get_origin(dict[str, int]))

# Аргументы типа
print(get_origin(dict[str, int]))

```

---

# Python

Аннотации типов во время исполнения (runtime)

```py {*}{maxHeight: '400px'}
from typing import get_type_hints

def create_user(name: str, age: int) -> None:
    print(f"User {name}, age {age} created")


def call_with_type_check(func, **kwargs):
    hints = get_type_hints(func)

    for arg, value in kwargs.items():
        expected_type = hints.get(arg)
        if expected_type and not isinstance(value, expected_type):
            raise TypeError(
                f"Аргумент '{arg}' должен быть типа {expected_type.__name__}, "
                f"получен {type(value).__name__}"
            )

    return func(**kwargs)

call_with_type_check(create_user, name="Саша", age=18)
call_with_type_check(create_user, name="Ваня", age="21")
```

---
src: ./_shared.md#2
transition: none
hideInToc: true
---

---
hideInToc: true
---

<style scoped>
  li {
    font-size: 14px;
  }

  li p {
    margin: 6px 0;
  }
</style>

# Python

Асинхронное (неблокирующее) программирование

В `python` для асинхронности используется стандартная библиотека `asyncio`

### Определения
- **Блокирующая операция** - операция, блокирущая выполнение другого кода в текущем потоке программы, примеры: консольный вывод/вывод, http-запросы при помощи `requests`, чтение и запись файлов стандартной библиотекой

- **Корутина (Coroutine - Сопрограмма)** - это специальный объект, позволяющий приостанавливать выполнение функции и возобновлять его позже, при этом сохраняя своё состояние, позволяя выполняться другим операциям

- **Асинхронная функция** - функция, объявленная при помощи `async def`. Всегда неявно возвращает экземпляр `<class 'coroutine'>` и позволяет использовать внутри себя ключевое слово `await` для ожидания результата объекта, реализующего интерфейс `awaitable` (например, `Future` или другая корутина)


- **Цикл событиый (Event Loop)** - механизм, управляющий выполнением всех асинхронных задач, то есть решает, когда запустить новую корутину, когда приостановить или возобновить уже существующую

- **Задача (Task)** - объект, управляющий независимым выполнением корутины в цикле событий. Создаётся при помощи `asyncio.create_task()`. Примерно то же самое, что `Promise` в JS

---
hideInToc: true
---

# Python

Пример-сравнение синхронной и асинхронной программы

<div class="grid grid-cols-2 gap-4">

<<< @/../snippets/python/sync-async/sync-simple.py {*}{maxHeight: '400px'}

<<< @/../snippets/python/sync-async/async-simple.py {*}{maxHeight: '400px'}

</div>


---

<style scoped>
  h4 {
    font-size: 18px;
    font-weight: 600;
  }

  p, li {
    font-size: 14px;
    line-height: 1.1rem;
    font-weight: 400;
  }
</style>

# Практика

<div class="grid grid-cols-2 gap-4">

  <div>

#### 1. Знание языка

Напишите программу, принимающую 2 IP-адреса в качестве аргументов командой строки и выведите, сколько адресов находится между ними (включая начало и исключая конец)

  <div class="mb-2">

```sh
python ips-between.py 192.168.0.100 192.168.0.0 # 100
python ips-between.py 192.168.1.0 192.168.0.5 # 251
```

</div>

  - Обработайте ошибки (неправильный ввод, плюсик за использование регулярных выражений)
  - Если пользователь передал флаг `-h`, выведите информацию о программе и как ей пользоваться (`argparse`)

</div>
<div>

#### 2. Асинхронность и внешние зависимости

Напишите программу для мониторинга веб-сайтов, которая периодически определяет: **доступность сайта, время ответа от сервера и заголовок страницы**

Основные условия:
  - Создана виртуальная среда
  - Зависимости описаны в файле `requirements.txt`
  - Запросы выполняются асинхронно (`aiohttp`)
  - Адреса сайтов хранятся в константе
  - Программа разбита на модули и пакеты (как именно - на ваше усмотрение)

Дополнительные условия:
  - Адреса сайтов могут задаваться из файла (по адресу на каждой строке) или в качестве аргументов командной строки через пробел
  - Данные сохраняются в CSV (тоже асинхронно)
  - Если очень уж хотите, можете попробовать строить сравнительные графики с временами ответов (можно отдельной программой)

  </div>

</div>


---
src: ./_shared.md#1
---

---

# Дополнительные материалы

- [Habr - Введение в аннотации типов Python](https://habr.com/ru/companies/lamoda/articles/432656/) - цикл статей по работе с аннотациями типов
- [Python Type Annotations Full Guide](https://missourimrr.github.io/docs/python/type-annotations/full-guide.html)
- [PEP 484 - Type Hints](https://peps.python.org/pep-0484/)
- [Skillbox Media - Python venv: что такое виртуальное окружение и как им пользоваться](https://skillbox.ru/media/code/python-venv-chto-takoe-virtualnoe-okruzhenie-i-kak-im-polzovatsya/)
- [Skypro - Pyenv: безопасное управление разными версиями Python на одном ПК](https://sky.pro/wiki/python/ustanovka-neskolkih-versij-python-ispolzovanie-pyenv/)
- [Habr - Асинхронный python без головной боли (часть 1)](https://habr.com/ru/articles/667630/)