---
theme: default
title: Основы проектирования API, обзор архитектурных подходов / Курс по веб-разработке, 11 класс
class: text-center
drawings:
  persist: false
transition: slide-left
mdc: true
fonts:
  sans: Montserrat
hideInToc: true
browserExporter: true
---

# Курс по веб-разработке

<h2 class="color-gray-400 fw-200">Основы проектирования API, обзор архитектурных подходов</h2>

---

# API

Основы

<div class="mb-4">

> **API (Application Programming Interface, Программный интерфейс приложения, АПИ)** - набор правил и протоколов, которые определяются для коммуникации между программами

</div>

<div class="mb-4">

> **Интерфейс (Interface)** в общем случае - совокупность средств, методов и правил взаимодействия между элементами системы; граница между двумя объектами, исполняющими какие-то функции, требования к которой определяются неким стандартом
> - **Пользовательский интерфейс** - правила взаимодействия между пользователем и программой, например посредством командной строки (**Command Line Interface, CLI**) или графическими элементами (**Graphical User Interface, GUI**)
> - **Клавиатура и мышь** - элементы интерфейса для взаимодействия человека и компьютера
> - **Функция (в программировании)** - интерфейс для взаимодействия разработчика и программы, ограниченная каким-то набором аргументов и порядком их передачи

</div>

> **Сервис** — это автономный компонент системы, который предоставляет определенную функциональность при помощи API, например: сервис аутентификации пользователя, сервис обработки платежей, сервис генерации отчётов.

---

<style scoped>
  li {
    font-size: 12px;
    line-height: 1rem;
  }
</style>

# API

Разновидности

<div class="grid grid-cols-2 gap-2">
  <div class="p-4 bg-gray-200 dark:bg-gray-200 dark:bg-gray-800 border-rd-4">

##### По назначению

  - **Web API (HTTPS API)** - используют интернет-протоколы (обычно HTTP/HTTPS) для обмена данных между **клиентом** и **сервером**. Пример - API соц. сетей и других сайтов
  - **API операционных систем** - позволяет программам взаимодействовать с ОС и её ресурсами (WinAPI для Windows, POSIX для UNIX)
  - **Библиотеки и фреймворки**
  - **Аппаратные API** - обеспечивают доступ к периферии и "железу" компьютера (драйверы), управление внешними устройствами (IoT)

  </div>
  <div class="p-4 bg-gray-200 dark:bg-gray-800 border-rd-4">

##### По протоколу и архитектуре
  - **REST (RESTful API)** - данные передаются HTTP-запросами в различных форматах, обычно JSON и реже XML
  - **SOAP**  - строгий стандарт с XML-данными
  - **GraphQL** - позволяет запрашивать данные в заданной клиентом структуре
  - **RPC (Remote Procedure Call)** - удалённый вызов функции на сервере
  - **WebSocket API** - двусторонняя связь и данные в реальном времени в произвольном формате

  </div>
  <div class="p-4 bg-gray-200 dark:bg-gray-800 border-rd-4">

##### По доступности
  - **Публичные** - доступны для всех
  - **Партнёрские** - доступны только для авторизованных партнёров (например, API для работы с платёжной системой банка)
  - **Внутренние** - используются исключительно внутри организации для связи между разрабатываемыми ею сервисами

  </div>
  <div class="p-4 bg-gray-200 dark:bg-gray-800 border-rd-4">

##### По формату данных
  - **JSON API**
  - **XML API**
  - **Binary (бинарный) API** - например формат `protobuf` для `gRPC`

  </div>
</div>

---
transition: none
---

<style scoped>
  h3 {
    font-weight: 700;
    margin-top: 8px;
  }

  li, blockquote > p {
    font-size: 13px;
    line-height: 1.2rem;
  }

  p:has(+ ul) {
    margin: 4px 0;
  }
</style>

# REST API

<div class="mb-2">

> **REST API (Representational State Transfer; также RESTful API или просто REST)** - это архитектурный стиль взаимодействия компонентов распределённого (то есть просто состоящего из нескольких частей, например клиента и сервера) приложения в сети

</div>

<div class="mb-2">

> **Архитектурный стиль** – это набор согласованных ограничений и принципов проектирования систем, позволяющий добиться для неё определённых свойств

</div>

> **Ресурсы (Resources)** - это любая сущность, к которой можно получить доступ посредством API, например: пользователи, посты, заказы в интернет магазине и т.п. Каждому ресурсу соответствует уникальный URL-идентификатор, например `https://api.example.com/users`

### Назначение

<p class="font-size-3">Назначение REST в том, чтобы придать проектируемой системе такие свойства как:</p>

- Надёжность (за счёт отсутствия необходимости сохранять информацию о состоянии клиента, которая может быть утеряна)
- Производительность (за счёт использования кэша)
- Масштабируемость
- Прозрачность системы взаимодействия (особенно необходимая для приложений обслуживания сети)
- Простота интерфейсов
- Портативность компонентов
- Лёгкость внесения изменений
- Способность эволюционировать, приспосабливаясь к новым требованиям (на примере Всемирной паутины)

---
transition: none
---

<style scoped>
  .grid-cols-3 {
    h4 {
      font-size: 16px;
      line-height: 1.2rem;
      font-weight: 700;
    }

    p {
      font-size: 11px;
      line-height: 1.1rem;
      margin: 8px 0;
    }
  }
</style>

# REST API

Принципы

<div class="grid grid-cols-3 gap-2 mt-2">

<div class="p-4 bg-gray-200 dark:bg-gray-800 border-rd-4">

#### Клиент-серверная архитектура

Чёткое разграничение на клиент и сервер, где клиент - программа, запрашивающая данные, а сервер - их предоставляющая. Такое явное разделение улучшает масштабируемость и позволяет клиентам работать независимо от серверной логики

Также сервер может иметь базу данных. В данном случае надо понимать, что пара "сервер и БД" тоже будет парой "клиент-сервер", но сервером будет БД, а сам сервер — клиентом

Основной недостаток - единая точка отказа в виде сервера. Если отказал сервер и у нас нет дополнительных экземпляров, то для это будет означать неработоспособность системы

</div>
<div class="p-4 bg-gray-200 dark:bg-gray-800 border-rd-4">

#### Отсутствие состояния - Stateless

Принцип заключается в том, что сервер не должен хранить у себя информацию о сессии с клиентом. Он должен в каждом запросе получать всю информацию для обработки. Это упрощает обработку запросов и повышает отказоустойчивость системы

</div>
<div class="p-4 bg-gray-200 dark:bg-gray-800 border-rd-4">

#### Кеширование

Ответы сервера могут кешироваться, чтобы снизить нагрузку на сервер и ускорить получение данных клиентом. REST API поддерживает механизмы кеширования, такие как HTTP-заголовки `Cache-Control` и `ETag`, которые позволяют клиентам повторно использовать ранее полученные данные

</div>

</div>

---

<style scoped>
  .grid-cols-3 {
    h4 {
      font-size: 16px;
      line-height: 1.2rem;
      font-weight: 700;
    }

    p {
      font-size: 11px;
      line-height: 1.1rem;
      margin: 8px 0;
    }
  }
</style>

# REST API

Принципы

<div class="grid grid-cols-3 gap-2 my-2">
<div class="p-4 bg-gray-200 dark:bg-gray-800 border-rd-4">

#### Единообразие интерфейса и HATEOAS

REST API ориентируется на **ресурсы**, они должны иметь чёткую структуру и единообразные URL-адреса. Запросы к API выполняются с использованием стандартных методов HTTP, а данные передаются в предсказуемых форматах, таких как JSON или XML.

С помощью HATEOAS (необязательного принципа) клиент можно полностью отделить от сервера, давая узнать о доступных для ресурсов действиях при помощи гипермедиа. Подробнее можете почитать подробнее сами (ссылка есть на слайде с дополнительными материалами)

</div>
<div class="p-4 bg-gray-200 dark:bg-gray-800 border-rd-4">

#### Слоистая система - Layered System

Клиент может взаимодействовать не напрямую с сервером, а через **независимые** промежуточные **узлы (слои)**, при этом клиент может не знать об их существовании. Промежуточные серверы выполняют, например, балансировку нагрузки, проксирование и могут использовать дополнительное кэширование

</div>
<div class="p-4 bg-gray-200 dark:bg-gray-800 border-rd-4">

#### Код по требованию - Code on Demand (Необязательный)

REST API может позволить расширить функциональность клиента за счёт загрузки кода с сервера в виде апплетов или сценариев (скриптов или небольших программ)

</div>

</div>

> Если сервис соблюдает только часть из принципов, то называется <b>REST-like</b>, если соблюдаются все требования - <b>RESTful</b>

---
transition: slide-up
---

<style scoped>
  .grid-cols-3 {
    h4 {
      font-size: 16px;
      line-height: 1.2rem;
      font-weight: 700;
    }

    p {
      font-size: 11px;
      line-height: 1.1rem;
      margin: 8px 0;
    }

    --slidev-code-font-size: 10px;
    --slidev-code-line-height: 12px;
  }
</style>

# REST API

HTTP-методы и пример

> В REST API используются HTTP-методы `GET`, `POST`, `PUT`, `PATCH` и `DELETE`

<div class="grid grid-cols-3 gap-2 mt-2">

<div class="p-4 bg-gray-200 dark:bg-gray-800 border-rd-4">

#### `GET` - получение ресурса
  Запрос:
  ```http
  GET /users/1 HTTP/1.1
  Host: api.example.com
  Content-Type: application/json
  ```

  Ответ:
  ```json
  {
    "id": 1,
    "name": "Иван Иванов",
    "email": "ivan@example.com"
  }
  ```

</div>

<div class="p-4 bg-gray-200 dark:bg-gray-800 border-rd-4">

#### `POST` - создание ресурса
  Запрос:
  ```http
  POST /users HTTP/1.1
  Host: api.example.com
  Content-Type: application/json

  {
    "name": "Шади Абдельсалам",
    "email": "shadi@example.com"
  }
  ```

  Ответ:
  ```json
  {
    "id": 2,
    "name": "Шади Абдельсалам",
    "email": "shadi@example.com"
  }
  ```

</div>

<div class="p-4 bg-gray-200 dark:bg-gray-800 border-rd-4">

#### `PUT` - полное обновление ресурса
  Запрос:
  ```http
  PUT /users/1 HTTP/1.1
  Host: api.example.com
  Content-Type: application/json

  {
    "name": "Саша Кузнецов",
    "email": "sasha@example.com"
  }
  ```

  Ответ:
  ```json
  {
    "id": 1,
    "name": "Саша Кузнецов",
    "email": "sasha@example.com"
  }
  ```

</div>

</div>

---

<style scoped>
  .grid-cols-3 {
    h4 {
      font-size: 16px;
      line-height: 1.2rem;
      font-weight: 700;
    }

    p {
      font-size: 11px;
      line-height: 1.1rem;
      margin: 8px 0;
    }

    --slidev-code-font-size: 10px;
    --slidev-code-line-height: 12px;
  }
</style>

<div class="grid grid-cols-3 gap-2 mb-4">

<div class="p-4 bg-gray-200 dark:bg-gray-800 border-rd-4">

#### `PATCH` - частичное обновление ресурса
  Запрос:
  ```http
  PATCH /users/1 HTTP/1.1
  Host: api.example.com
  Content-Type: application/json

  {
    "name": "Иван Кузнецов",
  }
  ```

  Ответ:
    Ответ:
  ```http
  HTTP/1.1 204 No Content
  // ИЛИ
  HTTP/1.1 200 OK
  ```

</div>
<div class="p-4 bg-gray-200 dark:bg-gray-800 border-rd-4">

#### `DELETE` - удаление ресурса
  Запрос:
  ```http
  DELETE /users/1 HTTP/1.1
  Host: api.example.com
  Content-Type: application/json
  ```

  Ответ:
  ```http
  HTTP/1.1 204 No Content
  // ИЛИ
  HTTP/1.1 200 OK
  ```
</div>

</div>

> **[Jikan](https://docs.api.jikan.moe/)** - пример публичного REST API (про аниме)

---

<style scoped>
  li {
    font-size: 14px;
    line-height: 1.2rem;
  }

  h3, h4 {
    font-weight: 700;
  }
</style>

# REST API

Инструменты для тестирования

<div class="grid grid-cols-2 gap-4">

<div>

### `curl`

`curl` - консольная утилита для передачи данных при помощи различных протоколов (в основном HTTP(-S), но можно и других). Для помощи можете использовать команды `curl -h` или `man curl`

#### Аргументы
- `-X` - HTTP-метод
- `-d` - тело запроса
- `-H` - заголовок
- `-v` - подробная информация о запросе и ответе
- `-L` - следование перенаправлениям

```sh
curl -X POST http://localhost:3000/submitForm -d \
'{ "key": "value" }' -H 'Accept: text/html' -v
```

</div>

<div>

### Postman

Продвинутая программа для тестирование API с графическим интерфейсом

![](/postman-ui.png)

</div>

</div>

---
transition: slide-up
---

# GraphQL

Краткий обзор

> **GraphQL** - **язык запрсов (QL - Query Language)** и вместе с этим их **среда выполнения**. Основная идея - позволить клиенту запрашивать только те данные, которые ему нужны.
> GraphQL API предоставляет **единственную конечную точку** (endpoint) для POST-запроса, на которую клиент посылает запрос с телом определённой структуры, а по ней сервер определяет, как нужно ответить

<img src="https://habrastorage.org/r/w1560/getpro/habr/upload_files/2e2/83c/dd3/2e283cdd3011e27ec2e0ab117bc08d3f.png" class="bg-gray-100 border-rd-4 mt-4 w-150 mx-auto" />

---
transition: slide-up
---

<style scoped>
  h4 {
    font-size: 15px;
    line-height: 1.2rem;
    margin-bottom: 8px;
    font-weight: 700;
  }

  div {
    --slidev-code-font-size: 8px;
    --slidev-code-line-height: 10px;
  }
</style>

<div class="mb-4">

> В основе GraphQL лежит схема - контракт между сервером и клиентом. Она определяет, что может и не может API, построенный на GraphQL, и как и какие данные может получить клиент. Представляет собой слой абстракции для гибкой работы с API, при этом скрывает детали реализации

</div>

> **SDL (Schema Definition Language, язык определения схемы)** - универсальный (не зависящий от конкретного языка программирования) формат описания структуры API, определяющий типы данных, которые есть в системе, и набор операций, доступных клиентам

<div class="grid grid-cols-3 mt-4 gap-4">

<div class="p-4 bg-gray-200 dark:bg-gray-800 border-rd-4">

#### Типы данных

```gql
type Track {
  id: ID!
  title: String!
  author: Author!
  thumbnail: String
  length: Int
}

type IncrementTrackViewsResponse {
  code: Int!
  sucess: Boolean!
  message String
  track: Track
}
```

</div>

<div class="p-4 bg-gray-200 dark:bg-gray-800 border-rd-4">

#### `Query` - запрос данных

```gql
type Query {
  "Запрос конкретного трека по его ID"
  track(trackId: ID!): Track
}

query getTrack($trackId: ID!) {
  track(id: $trackId) {
    id
    title
  }
}
```

</div>

<div class="p-4 bg-gray-200 dark:bg-gray-800 border-rd-4">

#### `Mutation` - изменение данных

```gql
type Mutation {
	incrementTrackViews(id: ID!): IncrementTrackViewsResponse!
}

mutation IncrementTrackViewsMutation($incrementTrackViewsId: ID!) {
  incrementTrackViews(id: $incrementTrackViewsId): {
    code
    success
    message
    track {
      id
      numberOfViews
    }
  }
}
```

</div>

</div>

---

<style scoped>
  h3 {
    font-weight: 700;
    margin-bottom: 12px;
  }

  li {
    font-size: 14px;
    line-height: 1.3rem;
  }
</style>

<div class="grid grid-cols-2 gap-2 mb-12">

<div>

### Преимущества

- **Получение только необходимых данных**
- **Один запрос - много ресурсов** - за один запрос клиент может получить данные по разным сущностям
- **Сколько угодно источников данных** - источником данных для сервера может являться база данных, другой сервер, файл или что угодно ещё
- **Строгая типизация** - все типы и операции имеют определённые строгие типы
- **Качественный инструментарий** - готовые библиотеки, онлайн-среды для написания запросов
- **Простое версионирование**

</div>

<div>

### Недостатки

- **Сложность кэширования** - из-за изменчивости структуры входа/выхода сложно кэшировать запросы
- **Безопасность и авторизация** - доступ пользователя должен определяться не только по типам и операциям, но и по конкретным полям
- **Производительность** - из-за потенциально большой вложенности запросов и возможной рекурсии
- **Проблема N+1** (подробнее на занятии по базам данных)

</div>

</div>

[Публичный GraphQL API по "Рику и Морти"](https://rickandmortyapi.com/graphql)

---

<style scoped>
  h1 {
    font-size: 30px;
  }

  th {
    font-size: 14px;
    font-weight: 700;
  }

  td {
    font-size: 11px;
  }
</style>

# API - сравнение архитектурных подходов

<div class="table-dense">

| Параметр | REST | SOAP | GraphQL | RPC |
|----------|------|------|----------|-----|
| **Архитектура** | Ресурсно-ориентированная | Протокол на основе XML | Язык запросов | Вызов удаленных процедур |
| **Протокол** | HTTP(S) | HTTP, SMTP, TCP | HTTP(S) | HTTP, TCP, WebSockets |
| **Формат данных** | JSON, XML, HTML | XML | JSON | JSON, XML, бинарные форматы |
| **Подход к данным** | Фиксированные endpoints | Строго типизированные операции | Клиент определяет данные | Вызов методов |
| **Кэширование** | Встроенное (HTTP) | Нет встроенного | Клиентское | Зависит от реализации |
| **Безопасность** | HTTPS, OAuth, JWT | WS-Security, SSL | HTTPS, JWT | Зависит от реализации |
| **Сложность** | Низкая | Высокая | Средняя | Низкая-средняя |
| **Гибкость** | Ограниченная | Низкая | Очень высокая | Высокая |
| **Основное применение** | Веб-API, мобильные приложения, CRUD-операции | Финансовые системы, корпоративные приложения | Приложения со сложными требованиями к данным | Микросервисы, высокопроизводительные системы |
| **Преимущества** | Простота, кэширование, масштабируемость | Безопасность, стандартизация, надежность | Гибкость, эффективность данных | Производительность, низкая задержка |
| **Недостатки** | Over-fetching, множественные запросы | Сложность, избыточность | Сложность кэширования, N+1 проблемы | Слабая стандартизация, coupling |

</div>

---

<style scoped>
  .slidev-layout {
    overflow: auto;
  }

  h2 {
    font-size: 18px;
    font-weight: 700;
  }

  th, td {
    font-size: 12px;
  }

  th {
    font-weight: 600;
  }

  .card {
    background-color: #e5e7eb;
    padding: 8px;
    border-radius: 4px;
  }

  html.dark {
    .card {
      background-color: #1f2937;
    }
  }
</style>

# Регулярные выражения

> **Регулярные выражения (Regular Expressions, RegEx)** - формальный язык для поиска и манипуляций с подстроками в тексте. Описывается специальным шаблоном, содержащим набор символов и метасимволов для сопоставления с оригинальным текстом

<div v-click class="flex flex-col table-dense gap-4 mt-4">

<section id="anchors" class="card">
  <h2>Якоря (Anchors)</h2>
  <table data-section="Якоря">
    <thead>
      <tr>
        <th>Шаблон</th>
        <th>Что делает</th>
        <th>Пример</th>
        <th>Заметки</th>
      </tr>
    </thead>
    <tbody>
      <tr>
        <td class="pattern"><code>^</code>, <code>$</code></td>
        <td>Начало / конец строки.</td>
        <td><code>/^Hello$/</code></td>
        <td class="note">
          С флагом <code>m</code> — начало/конец каждой строки.
        </td>
      </tr>
      <tr>
        <td class="pattern"><code>\b</code>, <code>\B</code></td>
        <td>Граница слова / не граница.</td>
        <td><code>/\bword\b/</code></td>
        <td class="note">
          Основано на <code>\w</code> vs не-<code>\w</code>.
        </td>
      </tr>
      <tr>
        <td class="pattern"><code>\A</code>, <code>\Z</code> (PCRE)</td>
        <td>Начало / конец входа (не строки).</td>
        <td><code>/\A\d+/</code></td>
        <td class="note">
          В JS используйте <code>^</code> и <code>$</code>.
        </td>
      </tr>
    </tbody>
  </table>
</section>

<section id="literals" class="card">
  <h2>Литералы и экранирование</h2>
  <table data-section="Литералы">
    <thead>
      <tr>
        <th>Шаблон</th>
        <th>Что делает</th>
        <th>Пример</th>
        <th>Заметки</th>
      </tr>
    </thead>
    <tbody>
      <tr>
        <td class="pattern">
          <code>\.</code> <span class="badge">экранир.</span>
        </td>
        <td>Буквальная точка.</td>
        <td>
          <code>/file\.txt/</code> совпадёт с <code>file.txt</code>
        </td>
        <td class="note">
          Без экранирования <code>.</code> — любой символ.
        </td>
      </tr>
      <tr>
        <td class="pattern">
          <code>\*</code>, <code>\+</code>, <code>\?</code>,
          <code>\|</code>, <code>\(\)</code>, <code>\[\]</code>,
          <code>\{\}</code>
        </td>
        <td>Экранированные метасимволы.</td>
        <td><code>/price\?/</code></td>
        <td class="note">
          Экранируйте метасимволы, когда нужны буквально.
        </td>
      </tr>
      <tr>
        <td class="pattern">
          <code>\n</code>, <code>\r</code>, <code>\t</code>
        </td>
        <td>Спец-символы перевода строки/возврата/табуляции.</td>
        <td><code>/\t\w+/</code></td>
        <td class="note">
          В JS / PCRE стандартные escape-последовательности.
        </td>
      </tr>
      <tr>
        <td class="pattern">
          <code>\xHH</code>, <code>\uHHHH</code>, <code>\u{HHHH}</code>
        </td>
        <td>Шестнадцатеричные/Unicode-коды.</td>
        <td><code>/\u{1F600}/u</code></td>
        <td class="note">
          Форма <code>\u{…}</code> требует флаг <code>u</code> (JS).
        </td>
      </tr>
    </tbody>
  </table>
</section>

<section id="classes" class="card">
  <h2>Классы символов (Character classes)</h2>
  <table data-section="Классы">
    <thead>
      <tr>
        <th>Шаблон</th>
        <th>Что делает</th>
        <th>Пример</th>
        <th>Заметки</th>
      </tr>
    </thead>
    <tbody>
      <tr>
        <td class="pattern"><code>[abc]</code></td>
        <td>Любой из перечисленных символов.</td>
        <td><code>/gr[ae]y/</code> → <em>gray</em>, <em>grey</em></td>
        <td class="note"></td>
      </tr>
      <tr>
        <td class="pattern"><code>[^abc]</code></td>
        <td>Любой, кроме перечисленных.</td>
        <td><code>/[^\d\s]/</code></td>
        <td class="note">Отрицание внутри класса.</td>
      </tr>
      <tr>
        <td class="pattern">
          <code>[a-z]</code>, <code>[A-Z]</code>, <code>[0-9]</code>
        </td>
        <td>Диапазоны символов.</td>
        <td><code>/[A-Za-z0-9_]/</code></td>
        <td class="note">Зависит от кодировки / локали.</td>
      </tr>
      <tr>
        <td class="pattern"><code>\w</code>, <code>\W</code></td>
        <td>Символ слова (<code>~[a-zA-Z0-9_]</code>) / не символ слова.</td>
        <td><code>/\w+\b/</code></td>
        <td class="note">
          В JS — [A-Za-z0-9_]. Для Unicode-слова используйте
          <code>u</code> и <code>\p{L}</code>.
        </td>
      </tr>
      <tr>
        <td class="pattern"><code>\d</code>, <code>\D</code></td>
        <td>Цифра / не цифра.</td>
        <td><code>/\d{2,4}/</code></td>
        <td class="note">
          В Unicode-режиме учитывает все цифры, завися от движка.
        </td>
      </tr>
      <tr>
        <td class="pattern"><code>\s</code>, <code>\S</code></td>
        <td>Пробельный / непрабельный символ.</td>
        <td><code>/\S+@\S+/</code></td>
        <td class="note"></td>
      </tr>
      <tr>
        <td class="pattern"><code>.</code></td>
        <td>Любой символ кроме переноса строки.</td>
        <td><code>/a.+z/</code></td>
        <td class="note">
          С флагом <code>s</code> точка включает перенос строки.
        </td>
      </tr>
      <tr>
        <td class="pattern"><code>\p{…}</code>, <code>\P{…}</code></td>
        <td>Unicode-свойства (категории).</td>
        <td><code>/\p{L}+/u</code></td>
        <td class="note">
          Требует <code>u</code>. Примеры: <code>L</code> (буквы),
          <code>N</code> (числа), <code>Script=Greek</code>.
        </td>
      </tr>
    </tbody>
  </table>
</section>

<section id="quant" class="card">
  <h2>Квантификаторы (Quantifiers)</h2>

> **Quantifier (квантификатор)** — слово или фраза в английском языке, которая указывает на количество или объём чего-либо

  <table data-section="Кванторы">
    <thead>
      <tr>
        <th>Шаблон</th>
        <th>Что делает</th>
        <th>Пример</th>
        <th>Заметки</th>
      </tr>
    </thead>
    <tbody>
      <tr>
        <td class="pattern">
          <code>{n}</code>, <code>{n,}</code>, <code>{n,m}</code>
        </td>
        <td>Точное, минимум, диапазон повторений.</td>
        <td><code>/\d{2,4}/</code></td>
        <td class="note"></td>
      </tr>
      <tr>
        <td class="pattern">
          <code>*</code>, <code>+</code>, <code>?</code>
        </td>
        <td>0+ / 1+ / 0 или 1 повторений.</td>
        <td><code>/a*b+/</code></td>
        <td class="note">По умолчанию жадные.</td>
      </tr>
      <tr>
        <td class="pattern">
          <code>*?</code>, <code>+?</code>, <code>??</code>
        </td>
        <td>Ленивые (lazy) квантификаторы - ищут подстроку минимальной длинны</td>
        <td><code>/".*?"/</code></td>
        <td class="note">Берут минимум, достаточный для совпадения.</td>
      </tr>
      <tr>
        <td class="pattern">
          <code>*+</code>, <code>++</code>, <code>?+</code>
        </td>
        <td>Собственнические (possessive) кванторы - ищут подстроку максимальной длинны</td>
        <td><code>/a++b/</code></td>
        <td class="note">
          Поддержка зависит от движка (PCRE поддерживает, JS — через
          атомарные группы)
        </td>
      </tr>
    </tbody>
  </table>
</section>

<section id="grouping" class="card">
  <h2>Группы (Group Constructs)</h2>
  <table data-section="Группы">
    <thead>
      <tr>
        <th>Шаблон</th>
        <th>Что делает</th>
        <th>Пример</th>
        <th>Заметки</th>
      </tr>
    </thead>
    <tbody>
      <tr>
        <td class="pattern"><code>(…)</code></td>
        <td>Захватывающая группа.</td>
        <td><code>/(\d{3})-(\d{2})-(\d{2})/</code></td>
        <td class="note">
          Доступ по <code>\1</code>, <code>$1</code>, именам.
        </td>
      </tr>
      <tr>
        <td class="pattern"><code>(?:…)</code></td>
        <td>Незахватывающая (Non-capturing) группа.</td>
        <td><code>/(?:Mr|Ms)\.?\s+\w+/</code></td>
        <td class="note">Оптимизирует без хранения подгрупп.</td>
      </tr>
      <tr>
        <td class="pattern">
          <code>(?&lt;name&gt;…)</code>, <code>(?'name'…)</code>
        </td>
        <td>Именованная группа.</td>
        <td><code>/(?&lt;area&gt;\d{3})-(?&lt;num&gt;\d{7})/</code></td>
        <td class="note">В JS доступ по <code>groups.name</code>.</td>
      </tr>
      <tr>
        <td class="pattern"><code>a|b</code></td>
        <td>Альтернация (ИЛИ).</td>
        <td><code>/(cat|dog)/</code></td>
        <td class="note">Оценивается слева направо.</td>
      </tr>
      <tr>
        <td class="pattern"><code>(?>…)</code></td>
        <td>Атомарная группа - ищет подстроку максимальной длинны без захвата.</td>
        <td><code>/(?>a+)+b/</code></td>
        <td class="note">
          Запрещает откат; в JS не поддерживается.
        </td>
      </tr>
    </tbody>
  </table>
</section>

<section id="look" class="card">
  <h2>Просмотры (Lookaround)</h2>
  <table data-section="Просмотры">
    <thead>
      <tr>
        <th>Шаблон</th>
        <th>Что делает</th>
        <th>Пример</th>
        <th>Заметки</th>
      </tr>
    </thead>
    <tbody>
      <tr>
        <td class="pattern"><code>(?=…)</code></td>
        <td>Положительный просмотр вперёд - проверяет, что данная подстрока может быть найдена в этом месте, не потребляя символов</td>
        <td><code>/\w+(?=\.)/</code> → слово перед точкой</td>
        <td class="note"></td>
      </tr>
      <tr>
        <td class="pattern"><code>(?!…)</code></td>
        <td>Отрицательный просмотр вперёд.</td>
        <td>
          <code>/(?!https?:)\/\//</code> — двойной слэш, не протокол
        </td>
        <td class="note"></td>
      </tr>
      <tr>
        <td class="pattern"><code>(?&lt;=…)</code></td>
        <td>Положительный просмотр назад.</td>
        <td>
          <code>/(?&lt;=\$)\d+(?:,\d{3})*/</code> — числа после
          <code>$</code>
        </td>
        <td class="note">
          В старых JS-движках не поддерживался, сейчас поддержка шире.
        </td>
      </tr>
      <tr>
        <td class="pattern"><code>(?&lt;!…)</code></td>
        <td>Отрицательный просмотр назад.</td>
        <td>
          <code>/(?&lt;!@)\b\w+/</code> — слово, не после <code>@</code>
        </td>
        <td class="note"></td>
      </tr>
    </tbody>
  </table>
</section>

<section id="backrefs" class="card">
  <h2>Обратные ссылки (Backtracking) и замены</h2>
  <table data-section="Backrefs">
    <thead>
      <tr>
        <th>Шаблон</th>
        <th>Что делает</th>
        <th>Пример</th>
        <th>Заметки</th>
      </tr>
    </thead>
    <tbody>
      <tr>
        <td class="pattern"><code>\1, \2…</code></td>
        <td>Ссылка на захваченную группу.</td>
        <td><code>/(\w+)\s+\1/</code> — удвоенные слова</td>
        <td class="note"></td>
      </tr>
      <tr>
        <td class="pattern"><code>\k&lt;name&gt;</code></td>
        <td>Ссылка на именованную группу.</td>
        <td>
          <code>/(?&lt;q&gt;"|')(.*?)\k&lt;q&gt;/</code> — совпадающие
          кавычки
        </td>
        <td class="note">
          JS: <code>\k&lt;name&gt;</code>, PCRE: тоже поддерживает.
        </td>
      </tr>
      <tr>
        <td class="pattern"><code>$1, $&amp;, $` , $'</code></td>
        <td>Спец-плейсхолдеры в подстановках (JS/PCRE).</td>
        <td><code>str.replace(/(\w+)/, "[$1]")</code></td>
        <td class="note">
          <code>$&amp;</code> — всё совпадение; <code>$`</code> — до;
          <code>$'</code> — после.
        </td>
      </tr>
    </tbody>
  </table>
</section>

<section id="flags" class="card">
  <h2>Флаги (flags) / модификаторы (modifiers)</h2>
  <table data-section="Флаги">
    <thead>
      <tr>
        <th>Флаг</th>
        <th>Что делает</th>
        <th>Пример</th>
        <th>Заметки</th>
      </tr>
    </thead>
    <tbody>
      <tr>
        <td class="pattern"><code>i</code></td>
        <td>Без учета регистра.</td>
        <td><code>/user/i</code></td>
        <td class="note"></td>
      </tr>
      <tr>
        <td class="pattern"><code>m</code></td>
        <td>Многострочный режим (^ и $ на каждую строку).</td>
        <td><code>/^\w+$/m</code></td>
        <td class="note"></td>
      </tr>
      <tr>
        <td class="pattern"><code>s</code></td>
        <td>"dotAll": <code>.</code> включает перенос строки.</td>
        <td><code>/.+/s</code></td>
        <td class="note"></td>
      </tr>
      <tr>
        <td class="pattern"><code>g</code></td>
        <td>Глобальный поиск (JS).</td>
        <td><code>/\w+/g</code></td>
        <td class="note">Возвращает все совпадения.</td>
      </tr>
      <tr>
        <td class="pattern"><code>u</code></td>
        <td>Unicode-режим (JS).</td>
        <td><code>/\p{L}+/u</code></td>
        <td class="note">
          Нужен для <code>\u{…}</code> и <code>\p{…}</code>.
        </td>
      </tr>
      <tr>
        <td class="pattern"><code>x</code> (PCRE)</td>
        <td>Расширенный синтаксис: пробелы/комменты игнорируются.</td>
        <td><code>/\d{3} # код\n-?\d{7}/x</code></td>
        <td class="note">
          JS: аналогов нет, используйте флагов нет — или конкатенацию
          строк.
        </td>
      </tr>
    </tbody>
  </table>
</section>

</div>

---

<style scoped>

</style>

# Регулярные выражения

Применение

```js {*}{maxHeight:'400px'}
const namePattern = /^([а-я]+)\s([а-я]+)\s([а-я]+)$/i
const namePattern2 = new RegExp('^([а-я]+)\s([а-я]+)\s([а-я]+)$', 'i')

// 1. test() - проверка наличия совпадения
'Иванов Иван Иванович'.test(namePattern)
// true
'Какой-то текст'.test(namePattern)
// false

// 2. exec() - поиск с подробной информацией, то же самое что match без флага 'g'
namePattern.exec('Иванов Иван Иванович')
// ['Иванов Иван Иванович', 'Иванов', 'Иван', 'Иванович', ...]

// 3. match() - поиск совпадений
'Иванов Иван Иванович'.match(namePattern)
// ['Иванов Иван Иванович', 'Иванов', 'Иван', 'Иванович', ...]

// 4. matchAll() - поиск всех совпадений с детальной информацией
'Иванов Иван Иванович'.match(/([а-я]+)/i)

// 5. search() - поиск индекса
'Google Yandex VK'.search(/y.+x/i)
// 7

// 6. replace() - замена
const htmlText = '<div class="container"><p>Hello</p></div>';
const cleanHtml = htmlText.replace(/<[^>]+>/g, '');

// 8. replaceAll() - замена всех вхождений, то же самое, что replace() с флагом 'g'
'Google;\n Yandex  \n\t;    VK'.replaceAll(/\s*;\s*/g, ',')
// 'Google,Yandex,VK'

// 9. split() - разделение строки
'Google;\n Yandex  \n\t;    VK'.split(/\s*;\s*/g)
// ['Google', 'Yandex', 'VK']

```

---

<style scoped>
  li {
    font-size: 12px;
    line-height: 1.2rem;
  }
</style>

# Практика

#### Регулярные выражения

- Напишите программу, которая принимает url и удаляет всё после первого символа `#`
  - `"www.example.com#about" -> "www.codewars.com"`
  - `"www.example.com?page=1" ->"www.codewars.com?page=1"`
- Напишите программу, которая принимает строку из нескольких слов и возвращает новую строку по примерам. При этом если строка пуста или длиннее 100 символов, верните `false`
  - `" Потрясающе    длинный\n  \t хэштэг" -> "#ПотрясающеДлинныйХэштэг"`
  - `"    Hello     World   " -> "#HelloWorld"`
  - `"" -> false`
- Напишите программу, валидирующую IPv4-адрес
- Напишите программу, валидирую объект с данными пользователя - `validateUserData({ email: ..., password: ..., phone: ... })`
  - Возвращается `true`, если все поля прошли валидацию
  - Возвращается объект с ошибками, если какие-то поля не прошли валидацию, например - `{ password: false, phone: false }`
  - **Пароль** - строка, содержащая только латинские буквы, числа и символы `$&@_-!*` и имеющая длину от 8 до 20 символов


---
src: ./_shared.md#1
---

---

# Дополнительные материалы

## REST API
- [Yandex Cloud - REST API: для чего нужен и как работает](https://yandex.cloud/ru/docs/glossary/rest-api)
- [Habr - REST API — Что такое HATEOAS?](https://habr.com/ru/articles/483328/)

## Разное
- [Regex101](https://regex101.com/) - онлайн-среда для написания, объяснения работы и тестирования регулярных выражений
