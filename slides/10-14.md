---
theme: default
title: "Инструменты качества кода и язык TypeScript / Курс по веб-разработке, 10 класс"
class: text-center
drawings:
  persist: false
transition: slide-left
mdc: true
fonts:
  sans: Montserrat
hideInToc: true
browserExporter: true
---

# Курс по веб-разработке

<h2 class="color-gray-400 fw-200">Инструменты качества кода и язык TypeScript</h2>

---
class: table-dense
---

<style scoped>
  th {
    font-size: 12px !important;
    padding: 4px 8px;
  }

  td {
    font-size: 10px;
  }
</style>

# Контроль качества кода

| Категория | Назначение | Примеры инструментов (Python и JS) |
|------------|----------------------|-----------------------|
| **Форматирование и стиль (Code Style)** | Приведение кода к единому стилю, автоформатирование, сортировка импортов | `Prettier`, `Biome`, `EditorConfig` |
| **Линтинг (Linting)** | Проверка синтаксиса, ошибок, несоответствий стилю, "запахи" | `ESLint`, `TSLint`, `Stylelint`, `Biome` |
| **Статический анализ (Static Analysis)** | Анализ кода без выполнения: типы, безопасность, зависимости | `TypeScript`, `Flow`, `ESLint` |
| **Динамический анализ (Dynamic Analysis)** | Анализ программы во время её выполнения: профилирование (замер производительности) и расчёт тестового покрытия | `Chrome DevTools`, `Node.js Inspector`, `Sentry`, `clinic.js` |
| **Архитектурный линтинг (Architectural Linting)** | Проверка структуры проекта (например, допустимость импортов из определённых модулей или пакетов) | `eslint-plugin-boundaries`, `dependency-cruiser`, `Madge` |
| **Тестирование (Testing)** | Проверка корректности работы функций, модулей и системы | `Jest`, `Vitest`, `React Testing Library`, `Cypress`, `Playwright` |
| **Документирование (Documentation)** | Документирование кода и отдельных компонентов | `Storybook`, `Docusaurus`, `MkDocs` |
| **Code Review** | Экспертная оценка кода, автоматизация комментариев в PR | Чек-листы стандартных проверок, `reviewdog`, `Danger`, `Gerrit` |
| **CI/CD и автоматизация (Automation)** | Автоматический запуск проверок при коммитах и сборках и генерация отчётов | `Husky`, `lint-staged`, `GitHub Actions`, `GitLab CI`, `Jenkins` |
| **Безопасность и аудит (Security & Auditing)** | Поиск нарушений безопасности в коде (недопустимые конструкции вроде `eval` или наличие конфиденциальных данных) и внешних зависимостях | `npm/yarn audit`, `OWASP Dependency-Check`, `Snyk`, `CodeQL` |

---

<style scoped>
  li {
    font-size: 12px;
    line-height: 1.2rem;
  }

  blockquote {
    margin-top: 8px;
  }

  div {
    --slidev-code-font-size: 8px;
    --slidev-code-line-height: 10px;
  }
</style>

# Форматировщики

> Инструменты, которые **автоматически приводят код к единому стилю** без участия разработчика

- `prettier` - стандартный инструмент для форматирования кода, минимально настраиваемый
- `EditorConfig` - универсальный инструмент для настройки стиля кода (не совсем форматировщик) вне зависимости от языка программирования и используемой IDE/редактора
- `Biome` - включает и форматирование, и линтинг, но многие его возможности пока находятся в экспериментальном состоянии

<div class="grid grid-cols-2 gap-2">

<div>

```json
{
  "arrowParens": "avoid",
  "trailingComma": "all",
  "semi": true,
  "useTabs": false,
  "tabWidth": 2,
  "bracketSpacing": true,
  "singleQuote": true,
  "bracketSameLine": false,
  "printWidth": 100
}
```

<figcaption>Пример конфигурации <code>prettier</code></figcaption>

</div>

<div>

```toml
root = true

[*]
end_of_line = lf
insert_final_newline = true

[*.{js,py}]
charset = utf-8

[*.py]
indent_style = space
indent_size = 4

[{package.json,.travis.yml}]
indent_style = space
indent_size = 2
```

<figcaption>Пример конфигурации <code>EditorConfig</code></figcaption>

</div>

</div>

> Обычно для популярных инструментов есть специальное расширение для всех популярных редакторов, позволяющие, например, применять автоформатирование при сохранении файла

---

# Линтеры и статические анализаторы

> **Линтеры** - инструменты, которые находят ошибки, антипаттерны и нарушения стиля на уровне синтаксиса
> **Статические анализаторы** - анализируют код без запуска (глубже линтеров) на наличие потенциальных ошибок

- `eslint` - линтер, технологический стандарт, поддерживает множество различных правил и может быть расширен при помощи плагинов
- `Biome`
- `TSLint` - линтер для языка typescript, может быть заменён расширением для eslint (`typescript-eslint`)
- `Stylelint` - линтер для css
- `TypeScript` - язык программирования и инструмент для статического анализа типов
- `Flow` - менее популярный аналог typescript

### Зачем это нужно?
- Ранний поиск ошибок
- Повышение качества и надёжности кода
- Улучшение безопасности

---

# Git-хуки

> **Git-хуки (Git Hooks)** - специальные скрипты, которые автоматически выполняются при определённых событиях в Git (например, коммит, пуш или слияние)

### Для чего нужны

- Автоматически запуск форматировщиков и/или линтеров перед коммитом, чтобы "плохой" код не попадал в репозиторий
- Проверка или автоматическая генерация сообщений коммита
- Автоматическаое обновление документации, версии проекта или файла `changelog` (содержит список изменений)

**Хуки** - любые исполняемые файлы (имеющие права на исполнение - `+x`). Они должны храниться в директории `.git/hooks` и иметь строго определённые имена (`pre-commit`, 'pre-push' и т.п.). Их можно писать вручную, а можно воспользоваться готовым инструментом, например `husky` (желательно вместе с `lint-staged`, чтобы запускать скрипты только тех файлов, которые попали в коммит)

---
src: ./_shared.md#6
---

---

# TypeScript

<div></div>

**TypeScript** — язык программирования, являющийся надстройкой над JavaScript, который добавляет статическую типизацию и проверку кода на этапе разработки и сборки проекта

### Зачем нужен?
- Раннее обнаружение ошибок
- Более понятный и самодокументируемый код
- Удобный рефакторинг
- Лучшую поддержку IDE (автокомплит, навигация)

### Как работает?
- Код пишется на TypeScript
- Компилятор (`tsc`) проверяет типы
- На выходе получается обычный JavaScript

---

# TypeScript

Экосистема

- **TypeScript Compiler (tsc)** - компилятор, преобразующий typescript в javascript
- `tsconfig.json` - файл конфигурации
- **TypeScript Language Server** - специальная программа, которую использует IDE для получения информации о коде и предоставлении дополнительных возможностей - автодополнений, типов данных, сигнатур функций и т.п. В VSCode установлен по умолчанию

---

<style scoped>
  div {
    --slidev-code-font-size: 9px;
    --slidev-code-line-height: 10px;
  }
</style>

# TypeScript

Конфигурация - `tsconfig.json`

```json
{
  // Основные настройки компилятора
  "compilerOptions": {
    "target": "ES2020", // В какую версию JS компилировать код
    "module": "ESNext", // Система модулей, для Node.js обычно: ESNext или CommonJS
    "moduleResolution": "Node", // Как TypeScript ищет модули
    "strict": true, // Включает все строгие проверки типов
    "noImplicitAny": true, // Запрещает неявный any
    "noImplicitReturns": true, // Проверяет, что все ветки функции что-то возвращают
    "noUnusedLocals": true, // Запрещает неиспользуемые локальные переменные
    "noUnusedParameters": true, // Запрещает неиспользуемые параметры функций
    "allowJs": false, // Разрешает импорт JS-файлов
    "checkJs": false, // Проверять ли JS-файлы (если allowJs = true)
    "sourceMap": true, // Генерировать ли sourcemap
    "outDir": "./dist", // Папка для скомпилированного кода
    "rootDir": "./src", // Корневая папка с исходным кодом
    "resolveJsonModule": true, // Поддержка импорта JSON файлов
    "strictNullChecks": true, // Проверка null и undefined
    "skipLibCheck": true, // Пропуск проверки типов в node_modules (ускоряет компиляцию)
    // Пути и алиасы импортов
    "baseUrl": ".",
    "paths": {
      "@/*": ["src/*"]
    }
  },
  "include": ["src"], // Какие файлы включать в компиляцию
  "exclude": ["node_modules", "dist"] // Какие файлы исключить
}
```

---

# TypeScript

Базовые типы

- `string`, `number`, `boolean`, строковые литералы (конкретный набор строк)
- `object`
- `Function`
- `null`, `undefined`
- `Array`, `[]`
- `any` - любой тип (**лучше не использовать!**)
- `unknown` - неизвестный тип, строгий аналог `any`. Обозначает переменную, значение которой может быть чем угодно, но при этом требует дополнительной проверки перед использованием
- `never` - значения, которые никогда не получаются (например, функция никогда не завершает выполнения)
- `void` - обозначает тип возврата функции, которая ничего не возвращает

---

# TypeScript

Базовые типы

```ts {monaco}
let str: string = "Some text"

str = "another string"
str = 123

// Тип не обязательно указывать явно
const n = 5; 

let anything: any;

anything = 123;
anything = "Don't use any type"
anything = true;
```

---

# TypeScript

Автовыведение типов

> **Автовыведение типов (Type inference)** - это способность TypeScript автоматически определять типы данных без их явного указания

```ts {monaco}
let age = 25;          // Вывод: `number`
const name = "Alice";  // Вывод: `string`
```

---

# TypeScript

Типы

> Ключевое слова `type` позволяет определить пользовательские типы данных

```ts {monaco}
type ID = number

type User = {
  id: ID
  name: string
}

type Admin = {
  id: ID
  name: string
  role: 'admin'
}

const user1: User = { id: 1, name: 'Иван' }
const user2: Admin = { id: 2, name: 'Шади', role: 'admin' }
```

---

# TypeScript

Интерфейсы

> Ключевое слова `interface` позволяет определить интерфейс - описание формы данных

```ts {monaco}
interface User {
  id: number
  name: string
}

interface Admin extends User {
  role: 'admin'
}

const user1: User = { id: 1, name: 'Иван' }
const user2: Admin = { id: 2, name: 'Шади', role: 'admin' }
```

---

# TypeScript

Различия типов и интерфейсов

<div class="grid grid-cols-2 gap-2">

<div>

### Тип

- Более универсален
- Может описывать объекты, примитивы, объединение и пересечение типов
- Не поддерживает declaration merging
- Удобен для сложных и композиционных типов

</div>
<div>

### Интерфейс

- Предназначен в первую очередь для объектов
- Может **расширяться** (`extends`)
- Поддерживает **слияние деклараций** (declaration merging, автоматическое объединение нескольких интерфейсов с одинаковым названием)
- Часто используется для публичных API и контрактов

</div>

</div>

---

# TypeScript

Операторы `keyof` и `typeof`

> Оператор `keyof` возвращает union-тип всех ключей объекта, `typeof` - тип переменной или функции

```ts {monaco}
type User = {
  id: number
  name: string
}

type UserKeys = keyof User

const user: User = { id: 1, name: 'Шади' }

type UserKeysInfered = keyof typeof user;

function printUser(user: User): string {
  return user.name
}

type PrintUser = typeof printUser
```

---

# TypeScript

Union types (объединённые типы)

> Оператор `|` (объединение) - позволяет указать, что значение может быть **одним из нескольких типов**

```ts {monaco}
type ID = string | number

const id1: ID = "some_uniq_id"
const id2: ID = 123
const id3: ID = { key: 'value' }
```

---

# TypeScript

Intersection type (пересеченные типы)

> Оператор `&` (объединение) - позволяет указать, что значение должно удовлетворять **всем типам**

```ts {monaco}
type ID = string & number

const id: ID = 1

type User = {
  id: number
  name: string
}

type Admin = User & {
  role: 'admin'
}

const admin: Admin = { id: 1, name: 'Шади', role: 'admin' }
```

---

# TypeScript

Слияние деклараций (Declaration merging)

```ts {monaco}
interface Box {
  height: number;
  width: number;
}

interface Box {
  scale: number;
}

let box1: Box = { height: 2, width: 3 };
let box2: Box = { height: 5, width: 6, scale: 10 };
```

---

# TypeScript

Сужение типов

> **Сужение типов (type narrowing)** - процесс "уточнения" типа переменной, чтобы TypeScript мог безопасно работать с ней


```ts {monaco}
type ID = string | number

function printId(id: ID) {
  if (typeof id === 'string') {
    // В этом блоке кода id имеет тип string
    console.log(id.toUpperCase())
  } else {
    // А тут - number
    console.log(id.toFixed(2))
  }
}
```

### Другие способы сужения

- Оператор `instanceof`
- Оператор `in`
- Защитники типов (Type Guards)

---

# TypeScript

Защитники (предохранители) типов

> **Защитник типа (Type guard)** - специальная пользовательская функция-предикат, проверяющая принадлежность переданного аргумента какому-то типу

```ts {monaco}
function isString(value: unknown): value is string {
  return typeof value === "string"
}

type User = {
  id: number
  name: string
}

function isUser(value: unknown): value is User {
  return typeof value === 'object' && value !== null && 'id' in value && 'name' in value
}

const user = { name: 'Фейковый Шади' }

if (isUser(user)) {
  console.log(`${user.id} ${user.name}`)
} else {
  console.log('Это не пользователь!')
}
```

---

# TypeScript

Операторы `as` и `satisfies`

> Оператор `as` позвляет привести тип переменной к другому

```ts {monaco}
const input = document.querySelector("#username") as HTMLInputElement;
console.log(input.value);

type ApiResponse = { id: number; name: string };
const data = await fetch("/api/user").then(res => res.json()) as ApiResponse;
console.log(data.name);
```

<br />

> Оператор `satisfies` позвляет проверить соответсвие переменной типу, при этом не изменяя настоящего типа

```ts {monaco}
type Route = { path: string; component: () => void };

const routes = [
  { path: "/home", component: () => console.log("Home") },
  { path: "/about", component: () => console.log("About"), meta: "extra" }
] satisfies Route[];
```

---

# TypeScript

Типизация объектов

```ts {monaco}
type User = {
  id: number
  name: string
  email?: string
  readonly role: 'user' | 'admin'
}

const user: User = { id: 1, name: '123', role: 'admin' }
user.role = 'user'
```

- `?` - необязательное поле
- `readonly` - неизменяемое поле

---

# TypeScript

Типизация функций

```ts {monaco}
const sum = (a: number, b: number): number => a + b

type User = {
  id: number
  name: string
}

interface Greet {
  (user: User): void
}

let greet: Greet = function (user) {
  console.log(`Hello, ${user.name}`)
}

type Logger = (message: string) => void

const log: Logger = msg => {
  console.log(msg)
}
```

---

# TypeScript

Работа с null и undefined

> `null` и `undefined` - частая причина ошибок во время исполнения

### Как избежать?
- Включить правило `strictNullChecks`
```ts {monaco}
let name: string = null // Ошибка
```
```ts {monaco}
let name: string | null = null
```
- Использовать операторы `?.` и `??` для безопасного доступа
```ts {monaco}
type User = {
    id: number
    address: {
      city?: string;
    }
}

const user: User = { id: 1, address: {} }
console.log(user.address.city) // Плохо
console.log(user.address?.city)
```

---

# TypeScript

`enum`

> `enum` (перечисление) — это способ задать **набор именованных значений** (часто используется для статусов, ролей, состояний и т.п.)

```ts {monaco} {height:'300px'}
enum Status {
  Pending,
  InProgress,
  Done
}

type Task = {
  id: number
  status: Status
}

function setStatus(status: Status) {
  if (status === Status.Done) {
    console.log('Task completed')
  }
}

setStatus(Status.InProgress)

enum Role {
  User = 'user',
  Admin = 'admin'
}

type User = {
  id: number
  role: Role
}

const user1: User = {
  id: 1,
  role: Role.Admin
}

const user2: User = {
  id: 1,
  role: 'user'
}

// Аналоги

type Role2 = 'user' | 'admin'

const USER_ROLES = {
  user: 'user',
  admin: 'admin',
} as const;

type Role3 = keyof typeof USER_ROLES
```

> **Важно:** `enum` генерирует реальный JavaScript-код

---

# TypeScript

Обобщённые типы

> **Обобщённые типы (Generics)** позволяют создавать **переиспользуемые и типобезопасные** компоненты, функции и структуры данных, работающие с разными типами

```ts {monaco} {height:'340px'}
interface ApiResponse<T> {
  data: T;
  error?: string;
}

type UserResponse = ApiResponse<{ id: number; name: string }>

const userResponse: UserResponse = {
  data: { id: 1, name: "Alice" }
};

// Ключевое слово extends позволяет ограничить обобщённый тип
function getLength<T extends { length: number }>(value: T): number {
  return value.length;
}

getLength("hello");
getLength([1, 2, 3]);

class Storage<T> {
  private items: T[] = [];

  add(item: T) {
    this.items.push(item);
  }

  getAll(): T[] {
    return this.items;
  }
}

const numberStorage = new Storage<number>();
numberStorage.add(1);
```

---

# TypeScript

Условные типы

> Для обобщённых типов можно использовать условия

```ts {monaco}
type IsArray<T> = T extends any[] ? true : false

type A = IsArray<[1, 2, 3]>
type B = IsString<42>

// Для union-типов условие применяется к каждому типу объединения,
// то есть оно дистрибутивно
type ToArrayUnion<T> = T extends any ? T[] : never

type ArrayTypeUnion = ToArrayUnion<string | number>

type ToArray<T> = T[]

type ArrayType = ToArray<string | number>

// Реальный пример
type ApiResult<T> = T extends Error
  ? { error: string }
  : { data: T }
```

---

# TypeScript

Mapped Types

> **Mapped Types** - специальная конструкция, позволяющая создать новый тип объекта на основании ключей существующего типа

```ts {monaco}
type User = {
  id: number
  name: string
  email: string
}

type UserFlags = {
  [K in keyof User]: boolean
}

type ReadonlyUser = {
  readonly [K in keyof User]: User[K]
}

// Можно менять названия ключей при помощи as
type Getters<Type> = {
    [Property in keyof Type as `get${Capitalize<string & Property>}`]: () => Type[Property]
};

type UserGetters = Getters<User>
```

---

# TypeScript

Оператор `infer`

> `infer` позволяет извлекать типы из других типов

```ts {monaco}
type ArrElementType<T> = T extends (infer U)[] ? U : T

type A = ArrElementType<string[]>
type B = ArrElementType<number[]>
type C = ArrElementType<boolean>

type FirstArg<T> =
  T extends (arg: infer A, ...rest: any[]) => any ? A : never

type ArgType = FirstArg<(x: string, y: number) => void>
```
---

# TypeScript

Утилитарные типы

> **Утилитарные типы (Utility types)** — встроенные типы TypeScript, которые помогают **создавать новые типы на основе существующих**

```ts {monaco}{height:'340px'}
type User = {
  id: number
  name: string
  email?: string
}

type UserDraft = Partial<User>

type UserRequired = Required<User>

type ReadonlyUser = Readonly<User>

type UserPreview = Pick<User, 'id' | 'name'>

type UserWithoutEmail = Omit<User, 'email'>

type Role = 'admin' | 'user'

const permissions: Record<Role, string[]> = {
  admin: ['read', 'write'],
  user: ['read']
}

function getUser() {
  return { id: 1, name: 'Alice' }
}

type UserInfered = ReturnType<typeof getUser>
```

---

# TypeScript

Классы

```ts {monaco}{height: '400px'}
// Модификаторы доступа
class Account {
  public owner: string        // доступен везде
  private balance: number     // только внутри класса
  protected id: string        // внутри класса и наследников
}

// Реализация интерфейса
interface Logger {
  log(message: string): void
}

class ConsoleLogger implements Logger {
  log(message: string) {
    console.log(message)
  }
}

// Абстрактные классы
// Позволяют только наследоваться, но не создавать экзепляр
abstract class Shape {
  abstract area(): number

  printArea() {
    console.log(this.area())
  }
}

class Circle extends Shape {
  constructor(private radius: number) {
    super()
  }

  area() {
    return Math.PI * this.radius ** 2
  }
}
```

---

# TypeScript

В React

```tsx {height:'400px'}
type FormProps = React.PropsWithChildren<{
  title?: string
  onClick?: VoidFunction
}>

const Form: React.FC<FormProps> = ({ title, onClick, children }) => {
  const [value, setValue] = useState<string>()

  const handleInputChange = (e: React.ChangeEvent<HTMLInputElement>) => {
    setValue(e.target.value)
  }

  return (
    <div onClick={onClick}>
      <h2>{title}</h2>
      <input onChange={} />
      {children}
    </div>
  )
}
```

---

# Практика

- Добавьте в свой итоговый проект:
  - Форматировщик
  - Линтер
  - Git-хук, запускающий инструменты качества кода при коммите
- Перепишите весь JS на TS

## TS
- Напишите тип `MyPick<T, K>`, извлекающий ключи union-типа `K` из объекта `T`
- Напишите тип `Return<Func>`, извлекающий тип возврата функции
- Напишите тип `AppendArgument<Fn, T>`, добавляющий к массиву аргументов функции `Fn` тип `T`

---
src: ./_shared.md#1
---

---

# Дополнительные материалы

- [TypeHero](https://typehero.dev/explore) - сайт для решения задач на TypeScript-типы
- [MyJs - Карманная книга по TypeScript](https://my-js.org/docs/guide/ts)
- [GitHub - Глубокое погружение в TypeScript](https://github.com/etroynov/typescript-book/blob/master/SUMMARY.md) - книга по углублённому TypeScript